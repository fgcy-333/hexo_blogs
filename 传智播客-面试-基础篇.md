---
title: 基础篇
date: 2022-08-23 21:21:55
tags:
- 院校帮-面试
categories: 
- 视频学习笔记

---

# 一、二分查找

### 1.0**算法描述**

1. 前提：有已排序数组 A（假设已经做好）

2. 定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）

3. 获取中间索引 M = Floor((L+R) /2)

4. 中间索引的值  A[M] 与待搜索的值 T 进行比较

   ① A[M] == T 表示找到，返回中间索引

   ② A[M] > T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找

   ③ A[M] < T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找

5. 当 L > R 时，表示没有找到，应结束循环



<!--more-->

**算法实现**

```java
public static int binarySearch(int[] a, int t) {
    int l = 0, r = a.length - 1, m;
    while (l <= r) {
        m = (l + r) / 2;
        if (a[m] == t) {
            return m;
        } else if (a[m] > t) {
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```



### 2.0 解决溢出问题方式一：

- 代码实现

~~~java
    /**
     * ClassName: binarySearchDemo
     * Description:解决整数溢出的二分查找 方式一 数学运算
     * date:2022/3/18
     *
     * @author fgcy
     * @since JDK 1.8
     */
    public int binarySearch1(int[] array, int target) {
        int left = 0;
        int right = array.length - 1;
        int counter = 0;
        while (left <= right) {
            System.out.println("比较" + ++counter + "次");
            //int middle = (left + right)/2;//如果两个很大的数相加，有可能溢出
            int middle = left + (right - left) / 2;
            if (target > array[middle]) {
                left = middle + 1;
            } else if (target < array[middle]) {
                right = middle - 1;
            } else {
                return middle;
            }
        }
        return -1;//等跳出循环还没退出方法，说明没找到
    }

    @Test
    public void test1() {
        int[] ints = {12, 33, 45, 46, 47, 88, 90, 99};
        System.out.println(binarySearch1(ints, 99));
    }
=============================================
比较1次
比较2次
比较3次
比较4次
7
~~~



### 3.0 解决整数溢出方式二

- 代码实现

~~~java
    /**
     * ClassName: binarySearchDemo
     * Description:解决整数溢出的二分查找 方式二 使用无符号右移一位【效率更高】
     * date:2022/3/18
     *
     * @author fgcy
     * @since JDK 1.8
     */

    public int binarySearch2(int[] array, int target) {
        int left = 0;
        int right = array.length - 1;
        int counter = 0;
        while (left <= right) {
            System.out.println("比较" + ++counter + "次");
            int middle = (left + right) >>> 1;//无符号右移一位，相当于除以二且处于最高位的必为零
            if (target > array[middle]) {
                left = middle + 1;
            } else if (target < array[middle]) {
                right = middle - 1;
            } else {
                return middle;
            }
        }
        return -1;//等跳出循环还没退出方法，说明没找到
    }
    @Test
    public void test1() {
        int[] ints = {12, 33, 45, 46, 47, 88, 90, 99};
        System.out.println(binarySearch2(ints, 99));
    }
==================================================
比较1次
比较2次
比较3次
比较4次
7
~~~

### 4.0 **其它考法**

1. 有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 

2. 使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较

3. 在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次

对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：

$$n = log_2N = log_{10}N/log_{10}2$$

其中 n 为查找次数，N 为元素个数





# 二、冒泡排序

### 0.0 **算法描述**

1. 依次比较数组中相邻两个元素大小，若 a[j] > a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后
2. 重复以上步骤，直到整个数组有序

**算法实现**

```java
public static void bubble(int[] a) {
    for (int j = 0; j < a.length - 1; j++) {
        // 一轮冒泡
        boolean swapped = false; // 是否发生了交换
        for (int i = 0; i < a.length - 1 - j; i++) {
            System.out.println("比较次数" + i);
            if (a[i] > a[i + 1]) {
                Utils.swap(a, i, i + 1);
                swapped = true;
            }
        }
        System.out.println("第" + j + "轮冒泡"
                           + Arrays.toString(a));
        if (!swapped) {
            break;
        }
    }
}
```

* 优化点1：每经过一轮冒泡，内层循环就可以减少一次
* 优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环



### 1.0 方式一

- 代码实现

~~~java
 	/**
     * 优化一冒泡排序：
     */
    @Test
    public void test() {
        int[] arr = {12, 3, 22, 7, 33, 44, 45, 55, 66, 77};
        System.out.println("原始数组是:" + Arrays.toString(arr));
        System.out.println("数组长度是" + arr.length + ",理论上跑" + (arr.length - 1) + "轮");
        for (int i = 0; i < arr.length - 1; i++) {
            //数组是否可以提前停止排序
            boolean stop = true;
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    //当本轮没有发生过交换时说明已经有序可以提前结束，但本轮有交换，所以时不能停止
                    stop = false;
                }
            }
            System.out.println("第" + (i + 1) + "轮：" + Arrays.toString(arr));
            //只要这一轮没有交换过顺序，说明可以提前停止
            if (stop) break;
        }
        System.out.println("排序结果:" + Arrays.toString(arr));
    }
=========================================================
原始数组是:[12, 3, 22, 7, 33, 44, 45, 55, 66, 77]
数组长度是10,理论上跑9轮
第1轮：[3, 12, 7, 22, 33, 44, 45, 55, 66, 77]
第2轮：[3, 7, 12, 22, 33, 44, 45, 55, 66, 77]
第3轮：[3, 7, 12, 22, 33, 44, 45, 55, 66, 77]
排序结果:[3, 7, 12, 22, 33, 44, 45, 55, 66, 77]
~~~

### 2.0 方式二

- 代码实现

~~~java
	/**
     * 优化二冒泡排序：
     */
    @Test
    public void test1() {
        int[] arr = {12, 3, 22, 7, 33, 44, 45, 55, 66, 77};
        System.out.println("原始数组是:" + Arrays.toString(arr));
        System.out.println("数组长度是" + arr.length + ",理论上跑" + (arr.length - 1) + "轮");
        //第一轮需要比较全部的元素
        int n = arr.length - 1;
        int counter = 0;
        while (true) {
            //当本轮已经有序了，不需要再进行排序了，此时通过将last的值0赋给n让排序终止
            int last = 0;
            for (int i = 0; i < n; i++) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                    //记录每次交换后的索引
                    last = i;
                }
            }
            System.out.println("第" + (++counter) + "轮：" + Arrays.toString(arr));
            //将【最后】交换的索引给n，该索引往左的都是未排序的，右边都是已经有序的
            n = last;
            //n会向0靠拢，当数组提前有序时，会有last=0赋给n，让其提前终止循环
            if (n == 0) break;
        }
        System.out.println("排序结果:" + Arrays.toString(arr));
    }
===================================================
原始数组是:[12, 3, 22, 7, 33, 44, 45, 55, 66, 77]
数组长度是10,理论上跑9轮
第1轮：[3, 12, 7, 22, 33, 44, 45, 55, 66, 77]
第2轮：[3, 7, 12, 22, 33, 44, 45, 55, 66, 77]
第3轮：[3, 7, 12, 22, 33, 44, 45, 55, 66, 77]
排序结果:[3, 7, 12, 22, 33, 44, 45, 55, 66, 77] 
~~~

### 3.0 冒泡排序总结

文字描述冒泡排序（以升序为例）
	依次比较数组中相邻的两个元素的大小，若arr[i]>arr[i+1]，则交换两个元素；
	两两都比较一遍称为一轮冒泡，结果是让最大的元素拍到最后
	重复上述步骤，直至整个数组有序
	
优化方式
	每轮冒泡时，最后一次交换的索引作为下一轮冒泡的比较次数；若这个值为零时，表示整个数组有序，直接退出外层循环即可



# 三、选择排序

### 1.0 **算法描述**

1. 将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集

2. 重复以上步骤，直到整个数组有序

- 代码实现

~~~java
	 @Test
    public void selectedSort() {
        int[] array = {21, 1, 65, 3, 9, 55, 0, -5};
        //i代表每轮所选择出的最小元素要交换到的目标索引【要把当前轮未排序区域的最小值放到该索引上】
        for (int i = 0; i < array.length - 1; i++) {
            //记录最小元素的索引
            int s = i;
            for (int j = s + 1; j < array.length; j++) {
                //用当前轮目前的最小值，和未排序区的元素进行比较【是s不能是i】
                if (array[s] > array[j]) {
                    //得到每轮中比较出的最小值的索引
                    s = j;
                }
            }
            //最小索引值与每轮想要交换到的目标索引相同时，说明不需要交换
            if (i != s) swap(array, i, s);
            System.out.println("每轮所得到的数组：" + Arrays.toString(array));
        }
        System.out.println(Arrays.toString(array));
    }
=========================================================
每轮所得到的数组：[-5, 1, 65, 3, 9, 55, 0, 21]
每轮所得到的数组：[-5, 0, 65, 3, 9, 55, 1, 21]
每轮所得到的数组：[-5, 0, 1, 3, 9, 55, 65, 21]
每轮所得到的数组：[-5, 0, 1, 3, 9, 55, 65, 21]
每轮所得到的数组：[-5, 0, 1, 3, 9, 55, 65, 21]
每轮所得到的数组：[-5, 0, 1, 3, 9, 21, 65, 55]
每轮所得到的数组：[-5, 0, 1, 3, 9, 21, 55, 65]
[-5, 0, 1, 3, 9, 21, 55, 65] 
~~~

- 选择排序思路

将数组分为两个子集，已排序的与未排序的，每轮从未排序的自己中选出最小的元素，放在已排序的子集中
重复以上步骤，直至数组有序



- 优化方式

为减少交换次数，可以先记录最先元素的索引，再在每一轮的最后进行交换



### 2.0与冒泡排序比较

1. 二者平均时间复杂度都是 $O(n^2)$

2. 选择排序一般要快于冒泡，因为其交换次数少

3. 但如果集合有序度高，冒泡优于选择

4. 冒泡属于稳定排序算法，而选择属于不稳定排序
   * 稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序
   * 不稳定排序则反之

# 四、插入排序

### 1.0 **算法描述**

1. 将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）

2. 重复以上步骤，直到整个数组有序

- 代码实现

~~~java
    @Test
    public void insertSorted() {
        int[] arr = {21, 18, 9, 22, 0, -2, 11};
        for (int i = 1; i < arr.length; i++) {
            int t = arr[i];//待插入的元素值
            int j = i - 1;//已排序区域的索引
            while (j >= 0) {
                if (t < arr[j]) {
                    //已取出的值，与有序区间的值进行比较，若有序区间的值较大则后移一位,直到有序值小于拿出的值，
                    // 一旦发现取出的值大于有序的值则退出循环，如果一直没找到，就会空出索引为0的有序空间
                    arr[j + 1] = arr[j];
                } else {
                    //必须打破，有效率问题有算法问题（当没有移位时，不能索引减一）
                    break;
                }
                j--;
            }
            arr[j + 1] = t;//将取出的值赋给空出的部分
            System.out.println("每轮排序的数组:" + Arrays.toString(arr));
        }
        System.out.println(Arrays.toString(arr));
    }
===========================================
每轮排序的数组:[18, 21, 9, 22, 0, -2, 11]
每轮排序的数组:[9, 18, 21, 22, 0, -2, 11]
每轮排序的数组:[9, 18, 21, 22, 0, -2, 11]
每轮排序的数组:[0, 9, 18, 21, 22, -2, 11]
每轮排序的数组:[-2, 0, 9, 18, 21, 22, 11]
每轮排序的数组:[-2, 0, 9, 11, 18, 21, 22]
[-2, 0, 9, 11, 18, 21, 22]

进程已结束，退出代码为 0
~~~

~~~java
    public void insertSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int t = arr[i];
            int j = i;
            while (j >= 1) {
                if (t < arr[j - 1]) {
                    arr[j] = arr[j - 1];
                    j--;
                } else {
                    break;
                }
            }
            arr[j] = t;
            System.out.println("每轮排序结果：" + Arrays.toString(arr));
        }
        System.out.println("最终排序结果：" + Arrays.toString(arr));
    }

    @Test
    public void test1() {
        int[] arr = {12, 18, 2, 34, 21, 11, 4};
        insertSorted(arr);
    }
每轮排序结果：[12, 18, 2, 34, 21, 11, 4]
每轮排序结果：[2, 12, 18, 34, 21, 11, 4]
每轮排序结果：[2, 12, 18, 34, 21, 11, 4]
每轮排序结果：[2, 12, 18, 21, 34, 11, 4]
每轮排序结果：[2, 11, 12, 18, 21, 34, 4]
每轮排序结果：[2, 4, 11, 12, 18, 21, 34]
最终排序结果：[2, 4, 11, 12, 18, 21, 34]
~~~





### 2.0 **与选择排序比较**

1. 二者平均时间复杂度都是 $O(n^2)$

2. 大部分情况下，插入都略优于选择

3. 有序集合插入的时间复杂度为 $O(n)$

4. 插入属于稳定排序算法，而选择属于不稳定排序

**提示**

> *插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序*

### 3.0 总结

文字描述
	将数组分为两个区域，已排序与未排序，每一轮从未排序中取第一个元素，插入到有序区中（需要保证顺序）
	重复上述步骤，直至整个数组有序
	
优化方式
	在与待插入元素进行比较时，若发现有序区的元素比待插入元素小，就代表找到了插入元素，无需进行后续比较
	插入时直接移动元素，而不是交换元素
	
与选择相比较
	两者的平均复杂度都是O(n)的平方
	大部分情况下，插入优于选择
	有序插入的时间复杂度为O(n)的平方，有序冒泡也是O(n)的平方
	插入排序属于稳定排序，选择属于不稳定



# 五、希尔排序

~~~java
 @Test
    public void test1() {
        int[] arr = {12, 18, 2, 34, 21, 11, 4};
        XierSort(arr);
    }

    public void XierSort(int[] arr) {
        int n = arr.length;
        int h = 1;
        while (h < n / 2) {
            h = h * 2 + 1;
        }

        for (; h > 0; h /= 2) {
            for (int i = h; i < n; i++) {
                int t = arr[i];
                int j = i;
                while (j >= h) {
                    if (arr[j - h] > t) {
                        arr[j] = arr[j - h];
                        j -= h;
                    } else {
                        break;
                    }
                }
                arr[j] = t;
            }
            System.out.println("每轮间隔下：" + Arrays.toString(arr));
        }

        System.out.println("最终结果：" + Arrays.toString(arr));
    }

每轮间隔下：[4, 18, 2, 12, 21, 11, 34]
每轮间隔下：[2, 4, 11, 12, 18, 21, 34]
最终结果：[2, 4, 11, 12, 18, 21, 34]
~~~



~~~java
package day01.sort;

import java.util.ArrayList;
import java.util.Arrays;

public class ShellSort {
    public static void main(String[] args) {
        int[] a = {7, 5, 19, 8, 4, 1};
        shell_2(a);
    }

   
    public static void shell_(int[] arr) {
        int N = arr.length;
        int h = 1;
        while (h < N / 2) {
            h = 2 * h + 1;
        }

        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h; j -= h) {
                    if (arr[j - h] > arr[j]) {
                        swap(arr, j, j - h);
                    } else {
                        break;
                    }
                }
            }
            h /= 2;
        }
        System.out.println(Arrays.toString(arr));
    }

    public static void shell_2(int[] arr) {
        int N = arr.length;
        int h = 1;
        while (h < N / 2) {
            h = h * 2 + 1;
        }
        while (h >= 1) {
            for (int i = h; i < N; i++) {
				//j >= h保证最小为零，不为负数                
                for (int j = i; j >= h; j -= h) {
                    if (arr[j - h] > arr[j]) {
                        swap(arr, j - h, j);
                    }
                }
            }
            h /= 2;
        }
        System.out.println(Arrays.toString(arr));
    }

    public static void swap(int[] arr, int i, int j) {
        int t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}

~~~



# 六、快速排序

### 1.0 **算法描述**

1. 每一轮排序选择一个基准点（pivot）进行分区
   1. 让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区
   2. 当分区完成时，基准点元素的位置就是其最终位置
2. 在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （[divide-and-conquer](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm)）
3. 从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案



### 2.0 单边循环快排

1. 选择最右边的元素作为基准点
2. j指针负责找到比基准点小的元素，一旦找到就与i进行交换
3. i指针维护小于基准点元素的边界，预计是每次交换的目标索引
4. 最后基准点与i交换，i即为分区位置



- **单边循环快排（lomuto 洛穆托分区方案）**

  1. 选择最右元素作为基准点元素

  2. j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换

  3. i 指针维护小于基准点元素的边界，也是每次交换的目标索引

  4. 最后基准点与 i 交换，i 即为分区位置

  

- 代码实现

~~~java
package com.itheima.find;

import org.junit.Test;

import java.util.Arrays;

public class QuickSortDemo {


    public static void swap(int[] array, int t1, int t2) {
        int temp = array[t1];
        array[t1] = array[t2];
        array[t2] = temp;
    }

    //每次调用都会两边都找一下
    public static void quick(int[] arr, int l, int h) {
        if (l >= h) return;
        final int i = quickSort(arr, l, h);
        quick(arr, l, i - 1);
        quick(arr, i + 1, h);
    }

    public static int quickSort(int[] arr, int l, int h) {
        //基准点元素(最后一个元素)
        int pv = arr[h];
        
        //i,j一开始都是区间最左边的元素，i负责维护小于基准点的元素的边界
        int i = l;
        
        //j的范围是从区间最左边到基准点元素(区间最右)，找到比基准点元素小的就与i的值进行交换
        for (int j = l; j < h; j++) {
            if (arr[j] < pv) {
                if (i != j) {
                    swap(arr, i, j);
                }
                //更换边界值索引，往右移是因为当前索引所知的值已经与j的值进行交换比基准点小
                i++;
            }
        }
        if (i != h) {//当边界值与基准元素是同一个时，不交换
            swap(arr, i, h);
        }
        System.out.println(Arrays.toString(arr));
        return i;
    }

    public static void main(String[] args) {
        int[] arr = {5, 3, 7, 2, 9, 8, 1, 4};
        quick(arr, 0, arr.length - 1);
    }
}
==================================
[3, 2, 1, 4, 9, 8, 7, 5]
[1, 2, 3, 4, 9, 8, 7, 5]
[1, 2, 3, 4, 9, 8, 7, 5]
[1, 2, 3, 4, 5, 8, 7, 9]
[1, 2, 3, 4, 5, 8, 7, 9]
[1, 2, 3, 4, 5, 7, 8, 9]
~~~



### 3.0 双边快排

**双边循环快排（不完全等价于 hoare 霍尔分区方案）**

1. 选择最左元素作为基准点元素
2. j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交
3. 最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置

要点

1. 基准点在左边，并且要先 j 后 i

2. while( **i** **< j** && a[j] > pv ) j-- 
3. while ( **i** **< j** && a[i] **<=** pv ) i++



1. 选择最左边元素作为基准点元素
2. j指针负责从右向左找比基准点小的元素，i指针负责从右往左找比基准点大的元素，一旦找到两者交换，直至i，j相交
3. 最后基准点与i（此时i与j相等）交换，i极为分区位置



- 几个要点

1. 基准点在左边，并且要先j后i
2. while(i<j && a[j]>pv) j--;
3. while(i<j && a[i]>=pv) i++;



- 代码实现

~~~java
package com.itheima.sort;

import java.util.Arrays;

public class QuickSortDemo2 {


    public static void swap(int[] array, int t1, int t2) {
        int temp = array[t1];
        array[t1] = array[t2];
        array[t2] = temp;
    }

    //每次调用都会两边都找一下
    public static void quick(int[] arr, int l, int h) {
        //当区间中只有一个元素时
        if (l >= h) return;
        final int i = quickSort(arr, l, h);
        //对左边分区进行排序
        quick(arr, l, i - 1);
        //对右边分区进行排序
        quick(arr, i + 1, h);
    }

    public static int quickSort(int[] arr, int l, int h) {
        //取区间最左边的值作为基准值
        int pv = arr[l];
        //i为区间左边第一个
        int i = l;
        //j为区间右边第一个
        int j = h;

        /*
         *先从j开始找，找到比基准值小的就记录下索引值；否则j--
         * 再从i开始找，找到比基准值大的就记录下索引；否则i++
         * 交换i，j两个索引处的值当他们相遇时，就退出循环
         * 交换基准值和i所对应的值
         * */
        while (i < j) {
            while (i < j && arr[j] > pv) j--;
            while (i < j && arr[i] <= pv) i++;
            swap(arr, i, j);
        }
        swap(arr, j, l);
        System.out.println(Arrays.toString(arr));
        return j;
    }

    public static void main(String[] args) {
        int[] arr = {5, 3, 7, 2, 9, 8, 1, 4};
        quick(arr, 0, arr.length - 1);
    }
}
======================================================
[1, 3, 4, 2, 5, 8, 9, 7]
[1, 3, 4, 2, 5, 8, 9, 7]
[1, 2, 3, 4, 5, 8, 9, 7]
[1, 2, 3, 4, 5, 7, 8, 9]
~~~

- 快速排序特点

1. 平均时间复杂度：O(n log2 n次方)，最坏时间复杂度：O(n 2平方)
2. 数据量大时，优势特别明显
3. 属于不稳定排序（选择排序）



**快排特点**

1. 平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$

2. 数据量较大时，优势非常明显

3. 属于不稳定排序



# 七、集合



## 1.0 ArrayList的扩容机制

- ​	**扩容规则**

1. ArrayList() 会使用长度为零的数组

2. ArrayList(int initialCapacity) 会使用指定容量的数组，扩容机制>>>1.5

3. public ArrayList(Collection<? extends E> c) 会使用 c 的大小作为数组容量

4. add(Object o) 首次扩容为 `10`，再次扩容为上次容量的 1.5 倍

5. addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)

>  其中第 4 点必须知道，其它几点视个人情况而定



- ArrayList的初始容量

  使用无参构造的方法:容量是零(长度为零的对象数组)
  使用一个int类型作为入参的构造方法:容量是入参(长度为入参长的对象数组)
  使用一个集合类型作为入参的构造方法：容量是集合的大小



- add()扩容

  当使用ArrayList的无参构造创建对象时，会给分配一个长度为零的数组，当加入第一个元素时，会创建一个长度为10的数组(扩容)，这个数组会替换掉原来的空数组； 

  当加入第十一个元素时【要插入的元素下标等于数组大小】，ArrayList又进行扩容，为原来的1.5倍(创建一个长度为15的数组，将原来数组的元素拷贝到新数组中)，原来的数组因为没有引用指向，会被gc干掉；

  当加入第16个元素时，ArrayList又进行扩容，将15>>>1 =7,15+7=22;创建一个长度为22的数组，将原来数组的元素拷贝到新数组中，原来的数组因为没有引用指向，会被gc干掉；



- addAll()扩容

1. 现在集合中元素个数为零，下一次会扩容为10，添加一个元素个数小于等于10的集合，此时该集合扩容为10；
2. 现在集合中元素个数为零，下一次会扩容为10，添加一个元素个数为22的集合，此时该集合扩容为22；Math.max(10,22)
3. 现在集合中元素个数为11个，下一次会扩容为22 ，添加一个元素个数为10的集合（此时所有元素个数为21<22），此时该集合扩容为22；Math.max(21,22)



- 扩容机制

1. ArrayList() 无参构造会使用长度为零的数组
2. ArrayList(int initialCapacity)会使用指定容量的数组，但是扩容是懒惰式的的，即在没有添加元素前，即使制定了长度，也不会创建数组
3. public ArrayList(Collection<? extends E> c)会使用c的大小作为数组容量
4. add(Object o)首次扩容为十，再次扩容为原来的1.5倍（先右移一位，再加上原来数组的长度）
5. addAll(Conllection c)没有元素时，扩容为Math.max(10,实际元素个数)，有元素时为Math.max(原容量的1.5倍，实际元素个数)



**首先，通过无参构造创建一个ArrayList对象**

~~~java
ArrayList arrayList = new ArrayList();
~~~



底层原理：调用无参构造器

~~~java
 public ArrayList() {
      this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
~~~

~~~java
 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
//常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的值为“{}”，为空数组
~~~

即使用ArrayList创建ArrayList对象时，并没有初始化底层数组elementData，等到调用add(E e) 方法的时候再初始化elementData，这种"懒加载"模式可以节省内存。

**调用add(E e) 方法**

~~~java
 arrayList.add("test");
~~~



底层原理：

~~~java
public boolean add(E e) {
        // 确认elementData容量是否足够
        ensureCapacityInternal(size + 1);  // 第一次调用add()方法时，size=0
        elementData[size++] = e;
        return true;
    }
~~~





先调用`ensureCapacityInternal`(int minCapacity) 方法,对数组容量进行检查，不够时则进行扩容:

~~~java
//当当前集合的数组为“{}”时，初始化容量，
private void ensureCapacityInternal(int minCapacity) {
    	//即第一次调用add(E e)， 如果elementData为"{}",重新定义minCapacity的值，赋值为DEFAULT_CAPACITY=10
    	// 即第一次调用add(E e)方法时，定义底层数组elementData的长度为10
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }
		// 判断是否需要扩容
        ensureExplicitCapacity(minCapacity);
    }
~~~



ensureExplicitCapacity(minCapacity) 判断是否需要扩容:

~~~java
private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
	
        // 第一次进入时，minCapacity=10,elementData.length=0,对数组进行扩容
        // 之后再进入时，minCapacity=size+1，elementData.length=10(每次扩容后会改变)，
        // 需要minCapacity>elementData.length成立，才能扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
~~~



grow(minCapacity) 对数组进行扩容:

~~~java
private void grow(int minCapacity) {
        // 将数组长度赋值给oldCapacity
        int oldCapacity = elementData.length;
    	
    	// 将oldCapacity右移一位再加上oldCapacity，即相当于newCapacity=1.5oldCapacity(不考虑精度损失)
        int newCapacity = oldCapacity + (oldCapacity >> 1);
    	
    	// 如果newCapacity还是小于minCapacity，直接将minCapacity赋值给newCapacity
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
    
    // 特殊情况：newCapacity的值过大，直接将整型最大值赋给newCapacity，
	// 即newCapacity=Integer.MAX_VALUE
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // 将elementData的数据拷贝到扩容后的数组
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

// 如果大于临界值，进行整型最大值的分配
//private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
~~~

结论：

使用ArrayList()创建ArrayList对象时，不会定义底层数组的长度，当第一次调用add(E e) 方法时，初始化定义底层数组的长度为10，之后调用add(E e)时，如果需要扩容，则调用grow(int minCapacity) 进行扩容,长度为原来的1.5倍。

ArrayList还有有参构造器：ArrayList(int initialCapacity) 和 ArrayList(Collection<? extends E> c)，前则创建可以指定初始容量的集合，后者创建一个包含指定collection元素的集合，两者的底层数组初始化和扩容机制与上述ArrayList()一样，且添加方法add(int index, E e)和add(E e)的扩容机制一样。




## 2.0 Iterator的fail-fast、fail-safe

Fail-Fast 与 Fail-Safe

* `ArrayList `    `Vector`是 fail-fast 的典型代表，**遍历的同时不能修改**，尽快失败

* `CopyOnWriteArrayList `是 fail-safe 的典型代表，**遍历的同时可以修改**，原理是读写分离



**fail-fast**

ArrayList时fail-fast的典型代表，遍历的同时不能修改，否则抛错，尽快失败
一旦发现遍历的时候别人来修改，立即抛异常

并发修改异常：

~~~java
    @Test
    public void test1(){
        final ArrayList<Student> list = new ArrayList<>();
        list.add(new Student("A"));
        list.add(new Student("B"));
        list.add(new Student("C"));
        list.add(new Student("D"));
        
        //调用增强for循环时，底层调用的是iterator迭代器
        for (Student student : list) {
            list.remove(student);  //java.util.ConcurrentModificationException
            System.out.println(student);
        }
    }
~~~



~~~java
//集合中 通过方法返回一个迭代器对象给增强for
public Iterator<E> iterator() {
        return new Itr();//会调用成员内部类的无参构造
}

  //成员内部类
 private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
     
     	//modCount是ArrayList的实例成员变量，记录当前ArrayList实例被修改的次数
     	//expectedModCount是迭代器实例维护的实例成员变量，记录一开始获得数组时，数组被修改的次数；
        int expectedModCount = modCount;

        Itr() {}

        public boolean hasNext() {
            //下一个元素的下标不等于该集合的大小
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }
     
     
     
     //-----------------------------------------------------------------
     //每次取出元素时都会查看集合是否被修改了，若改了就抛异常
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

~~~





**fail-save**

发现遍历的时候有人来修改，会采取一些策略，例如：**牺牲一致性**来让整个遍历完成
`CopyOnWriteArrayList`是` fail-safe` 的典型代表，遍历的同时可以修改，**原理是读写分离**

~~~mysql
    @Test
    public void test2(){
        final CopyOnWriteArrayList<Student> list = new CopyOnWriteArrayList<>();
        list.add(new Student("A"));
        list.add(new Student("B"));
        list.add(new Student("C"));
        list.add(new Student("D"));

        //增强for底层调用迭代器
        for (Student student : list) {
            list.remove(student);
            System.out.println(student);
        }
        System.out.println(list);
    }
~~~

~~~
Student{name:'A'}
Student{name:'B'}
Student{name:'C'}
Student{name:'D'}
[]
~~~



~~~java
	public Iterator<E> iterator() {
        return new COWIterator<E>(getArray(), 0);
    }

	//返回当前实例的数组，用于在迭代器中也维护一份（集合中每次添加新的元素就会创建一个长度+1的数组，将原数组的值复制到新数组中，	并将新数组作为底层数组），这样修改集合中的元素，对迭代器没有影响
    final Object[] getArray() {
        return array;
    }
~~~



对集合进行修改时，先复制出一份，再进行修改：

~~~java
	 public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
~~~

> CopyOnWriteArrayList的读写分离，弱一致性





## 3.0 LinkedList和ArrayList  

**LinkedList**

1. 基于双向链表，无需连续内存
2. 随机访问慢（要沿着链表遍历）
3. **头尾插入 删除**性能高
4. 占用内存多



**ArrayList**

1. 基于数组，需要连续内存
2. 随机访问快（指根据下标访问）
3. 尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低
4. 可以利用 cpu 缓存 --> 局部性原理



两者比较：
	ArrayList

  1. 基于数组，需要连续内存

   2. 随机访问快【根据下标访问】（根据数组地址，元素类型，索引综合计算）直接得到想要访问元素的地址

   3. 尾部插入、删除性能尚可；其他地方插入、删除需要移动元素，性能较低(尤其是头部)【**综合性能ArrayList要优于LinkedList**】

   4. 可以利用cpu缓存(cpu与内存之间访问所需的时间较长，所以使用cpu缓存，来提升读写性能)，局部性原理(访问一个数据的时候，

      cpu会默认认为它附近的元素有很大概率会被访问，所以一并加载进cpu缓存)



LinkedList

1. 基于双向链表，无需连续内存
2. 随机访问慢（需要沿着链表遍历）
3. 头尾插入性能较高，容易查到【查询中间元素，性能略低于ArrayList】
4. 内存占用多（除了要存储对象地址外，还需要存储头节点地址，尾节点地址，头部节点和尾部节点）



# 八、HashMap

## 1.0 基本数据结构

* 1.7 数组 + 链表
* 1.8 数组 + （链表 | 红黑树）



## 2.0 树化与退化

**树化意义**

* 红黑树用来避免 `DoS ` 攻击，防止链表超长时性能下降，树化应当是 偶然情况，是保底策略
* hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log⁡2N )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表
* hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 `0.75 `的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小

**树化规则**

* 当 **链表长度** 超过  **树化阈值 8** 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化



**退化规则**

* 情况1：在扩容时如果  **拆分树** 时，**树元素个数 <= 6** 则会退化链表
* 情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表



## 3.0 索引计算

**索引计算方法**

* 首先，计算对象的 hashCode()
* 再进行调用 HashMap 的 hash() 方法进行二次哈希
  * 二次 hash() 是为了综合高位数据，让哈希分布更为均匀
* 最后 二次hash值 & (capacity – 1) 得到索引 **hash%tab.length**等价于**hash&(tab.lenngth-1)**



**数组容量为何是 2 的 n 次幂**

1. 计算索引时效率更高：如果是 2 的 n 次幂可以使用 **位与运算** 代替取模
2. 扩容时重新计算索引效率更高： **hash & oldCap** == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap



**注意**

* 二次 hash 是为了配合 **容量是 2 的n次幂** 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash
* **容量是 2 的 n 次幂** 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 `Hashtable`



## 4.0 put 与扩容

**put 流程**

1. HashMap 是懒惰创建数组的，首次使用才创建数组
2. 计算索引（桶下标）
3. 如果桶下标还没人占用，创建 Node 占位返回
4. 如果桶下标已经有人占用
   1. 已经是 TreeNode 走红黑树的添加或更新逻辑
   2. 是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
5. 返回前检查容量是否超过阈值，一旦超过进行扩容

**1.7 与 1.8 的区别**

1. 链表插入节点时，1.7 是头插法，1.8 是尾插法

2. 1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容

3. 1.8 在扩容计算 Node 索引时，会优化

**扩容（加载）因子为何默认是 0.75f**

2. 大于这个值，空间节省了，但链表就会比较长影响性能
3. 小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多

>  在空间占用与查询时间之间取得较好的权衡

## 5.0 并发问题

**扩容死链（1.7 会存在）**

1.7 源码如下：

```java
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```

* **数据错乱（1.7，1.8 都会存在）**

​		多线程下put()元素导致元素缺失

## 6.0 key 的设计

- **key 的设计要求**

1. HashMap 的 key 可以为 null，但 Map 的其他实现则不然
2. 作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）
3. key 的 hashCode 应该有良好的散列性



- **String 对象的 hashCode() 设计**
  - 目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特
  - 字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 
  - 散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$
  - 31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 
    - 即 $32 ∗h -h $
    - 即 $2^5  ∗h -h$
    - 即 $h≪5  -h$
  - 想要散列效果较好就选择，是奇数的素数



- 底层结构，1.7与1.8有什么不同

1.7: 

 	 1. 数组 + 链表
 	 2. 链表插入节点时使用头插法
 	 3. 当前元素个数大于等于阈值(当前数组长度的四分之三)且要插入的元素的桶下标对应的位置有元素时，才进行扩容；
 	 4. 扩容后，要迁移元素；计算Node桶下标时没有优化（二次hash值 & oldCapacity == 0则不用移动；否则移动到新的桶下标位置去 新位置=当前桶下标+oldCacity）

1.8: 

 	1.  数组 + 链表(或红黑树)
 	2.  链表插入节点时使用尾插法
 	3.  当前元素个数大于等于阈值【当前数组长度的四分之三】时，扩容；
 	4.  扩容后，要迁移元素；计算Node桶下标时有优化（二次hash值 & oldCapacity == 0则不用移动；否则移动到新的桶下标位置去 新位置=当前桶下+oldCacity）

- **modecount的作用**

  HashMap时线程不安全的
  每修改一次hashMap对象，modcount就会+1；

  当使用迭代器遍历时，它会记录下当前的modcount数量【expextedModcount】，每次取下一个元素时就会，就会判断expectModcount与modcount是否相等，不相等，就并发修改异常

  

  

- 1.7

~~~java
1. 算桶下标
    static int indexFor(int h, int length) {
        // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    	//HashMap的Entry数组长度必须是  non-zero power of 2
    	//hashCode和数组长度减一按位与；数组长度减一是桶下标范围；
        return h & (length-1);
    }
2. 使用无参构造实例HashMap
        public HashMap() {
    	//默认初始化长度1<<4,加载因子0.75
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

3. put方法
        public V put(K key, V value) {
    	//判读数组是不是之前的空数组
    	//static final Entry<?,?>[] EMPTY_TABLE = {};数组一开始是长度为0的数组
    	// transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
        if (table == EMPTY_TABLE) {
            //数组是长度为0的数组，就创建一个长度不为零的数组
            inflateTable(threshold);
        }
        if (key == null)
            return putForNullKey(value);
    	//二次hash
        int hash = hash(key);
    	//算桶下标
        int i = indexFor(hash, table.length);
     	//遍历链表，添加元素时，如果发现链表中的键与新加的键相同时，旧值返回，新值替换旧值
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
		//修改次数
        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }

4. 头插法
        void createEntry(int hash, K key, V value, int bucketIndex) {
        Entry<K,V> e = table[bucketIndex];
    	//创建一个新的Entry对象，它的next是当前桶下标的数组中的引用，接着将将自己的引用赋给当前桶下标的数组
        table[bucketIndex] = new Entry<>(hash, key, value, e);
    	//当前总元素个数+1
        size++;
    }
    
5. 初始化数组大小 【当put元素时，才会创建有大小的数组】
        private void inflateTable(int toSize) {
        // Find a power of 2 >= toSize
    	//找到一个大于等于2的n次方数的数
    	//toSize是调用构造时传入的初始化参数，无参时默认16
    	//数组长度一定时 2的幂次方数
        int capacity = roundUpToPowerOf2(toSize);
		//扩容阈值
        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
        table = new Entry[capacity];
        initHashSeedAsNeeded(capacity);
    }
    
6. hashMap扩容
    
    void addEntry(int hash, K key, V value, int bucketIndex) {
    	//threshold通过加载因子和数组长度计算出的扩容阈值
    	//如果插入的桶下标中为null，即使现在已经满了阈值也不扩容【1.7】
        if ((size >= threshold) && (null != table[bucketIndex])) {
            //扩容为原来的两倍
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }

7. 扩容
    
        void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }
		//两倍长度数组
        Entry[] newTable = new Entry[newCapacity];
    	//元素转移
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }


8. 元素转移
    /*
    新数组下标有两种情况： 原来的桶下标；原来的桶下标+原来数组长度
    */
        void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
    	//遍历Entry数组
        for (Entry<K,V> e : table) {
            while(null != e) {
                Entry<K,V> next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                
                //得到新的桶下标，原来的hashCode新的数组长度
                int i = indexFor(e.hash, newCapacity);
                //【1.7】头插法，新数组桶下标中的引用作为要转移元素的下一个元素
                e.next = newTable[i];
                //要转移的元素作为桶下标中的引用
                newTable[i] = e;
                //在链表中下移
                e = next;
            }
        }
    }
9. 判断是否要rehash
    
        final boolean initHashSeedAsNeeded(int capacity) {
    	//hashSeed默认为零
        boolean currentAltHashing = hashSeed != 0;//false
    	//jvm是否启动
        boolean useAltHashing = sun.misc.VM.isBooted() &&
            	//当前数组容量是否大于某个值 默认整形最大 可以通过配置jvm参数改变
                (capacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);
    	//异或 不同为真 useAltHashing一定为真
        boolean switching = currentAltHashing ^ useAltHashing;
        if (switching) {
            hashSeed = useAltHashing
                ? sun.misc.Hashing.randomHashSeed(this)
                : 0;
        }
        return switching;
    }

10 
    
    
11. 多线程扩容时形成死链
~~~



- 为什么要用红黑树

当链表过长时，访问的效率会变低；而红黑树增删查改性能较高，当链表长度过长时，对查询性能的影星不大



- 为什么不直接红黑树

一般情况下，元素在哈希表中存储呈现泊松分布，很少有较长的链表；
在链表较短的情况下，查询的性能要优于红黑树；只有在链表很长的情况下，性能才远远不如红黑树
红黑树较于链表来说需要花费更大的存储空间；TressNode占用的空间比Node要大，所以，如非必要，尽量不要使用红黑树
树化是一种特殊情况，使用红黑树是为了避免被DOS攻击后导致链表过长使得查询性能降低；



- 红黑树的阈为什么是8

当hash值足够随机时，元素在hash表内呈现泊松分布，在负载因子0.75的情况下，长度超过8的链表出现的概率为0.00000006
选择8是为了让树化的概率足够小



- 什么时候会转成红黑树

当链表的长度大于8时，会先判断当前数组长度，如果数组长度小于64，则进行扩容；
当链表的长度大于8时，且数组长度大于等于64，此时会将链表转化为红黑树



- 什么时候会退化成链表

​	两种情况：

  1. 在扩容时，如果发生拆分树的情况，当树元素个数小于等于6时，就会退化成链表
     【当当前的数组所有元素个数大于当前数组长度的四分之三时，数组会扩容为原来的两倍】当移除树的节点时，若root、root.left、root.right、root.left.left有一个为null时，会退化成链表



- 索引值如何计算

1. 首先调用对象的hashCode方法得到原始hash，再通过HashMap的hash方法对原始hash进行计算得到二次hash;
2. 最后通过二次hash的值对当前数组长度取模获取索引值（桶下标）【这种是方便人计算，当数组容量是2的n次幂时，走的是下面 按位与的方式，效率更高】

~~~
97 % 16 =1  97&(16-1)=1
~~~



二次hash值 & （capacity-1）；注意：capacity的值必须是二的几次幂的形式



- HashMap中的hash

~~~java
	//当hashCode非空时，将原来的hashcode右移十六位取高位十六位，再与原来的hashCode作异或运算    
	//二次hash的好处，使得元素在数组中的分布尽可能随机
	static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
~~~

- 二次hash的目的

​		二次hash是为了综合高位数据，使得元素分布更加均匀



- 数组容量为何是2的n次幂

1. 计算索引时，如果使用的是2的n次幂的形式，那么取模运算可以用按位与来替代，效率更高；

2. 扩容时，如果 (hash & oldCapacity) ==  ，否则到新的位置（新位置=旧位置+oldCapacity）
3. 如果数组采用的是2的n次幂作为容量时，说明更加看重性能（与上面的1 2配合使用);如果采用质数作为数组容量，则hash分布更加均匀；不能说那种设计更优，这是设计者综	合各种因素最终选择使用2的n次幂作为数组容量



- put方法流程，1.7、1.8有何不同

1. HashMap是懒惰创建数组，首次使用put添加元素时才创建数组；
2. 计算索引（桶下标）【通过key的值得到hashCode，再通过HashMap的hash方法对hashCode进行计算得到二次hash的值，将 二次hash值 & (capacity-1)】
3. 如果桶下标没人占用，创建Node节点占用
4. 如果桶下标已经有人占用，分两种情况：
   一：已经是TreeNode，走红黑树的添加或更新逻辑(equals比较相同)
   二：是普通Node节点，走链表的更新(equals比较相同)或添加逻辑，当链表过长时就进行树化(链表长度是否大于8 && 数组长度是否大于等于16)
5. 添加元素后判断当前总元素个数是否大于当前数组长度的四分之三，一旦超过就扩容



- 加载因子为何默认是0.75f

1. 在空间占用与查询时间之间取得了较好的平衡
2. 大于这个值，空间节省了，但不能即时扩容会导致链表可能过长，影响查询性能；
3. 小于这个值，冲突减少了(链表长度可能会减少)，但空间频繁扩容，空间占用多



- Key是否能为null，作为key的对象有什么要求？

1. HashMap的key可以为null，但Map的其他实现类则不然 concurrentHashMap、HashTable、TreeMap；
2. 作为key的对象必须实现hashCode和equals
3. key的内容不可以修改



- String对象的hashCode如何设计？为什么每次乘以31？

任何对象的hashCode都应该足够独特，目标为达到较为均匀的散列效果
 hashCode设计：

    1. 字符串中的每个字符都可以表现为一个数字，称为Si，i的范围是 0到n-1，n是元素个数
    2. 代入散列公式： 
    
    S0*31^ n-1+S1*31^ n-2+s3*31^N-3+..."123456" 49*31^5 + 50*31^4 + 51*31^3 + 52*31^2 + 53*31^1 + 54*31^0
    
    3. `  31`  代入公式有较好的散列特性，并且算数可以优化 31x = (32-1)x = 32x-x = 2^5x-x = x<<5-x







- 多线程下操作HahMap

- - 问题一（数据错乱）：并发丢失数据

- - 问题二：死链

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/202210101009630.png)

---



# 九、设计模式

## 1.0 饿汉懒汉区别

饿汉本质是在静态代码块中调用私有构造；所以一碰到类就会初始化

懒汉本质就是不在静态代码块中，调用私有构造



## 2.0 饿汉单例

### 2.1 饿汉单例 (反射破坏单例+预防)

~~~java
package com.itheima.design_pattern;

import org.junit.Test;

import java.lang.reflect.Constructor;

/**
 * ClassName: SingletonDemo1
 * Description:饿汉式单例
 * date:2022/3/19
 *
 * @author fgcy
 * @since JDK 1.8
 */
public class SingletonDemo1 {
    private static final SingletonDemo1 INSTANCE = new SingletonDemo1();

    private SingletonDemo1() {

        //预防反射破坏单例
        if (INSTANCE != null) {
            throw new RuntimeException("the instance is already exist");
        }
        System.out.println("无参构造");
    }

    public static void otherMethod() {
        System.out.println("otherMethods()");
    }


    public static SingletonDemo1 getInstance() {
        return INSTANCE;
    }
}

class TestSingleton {

    public static void main(String[] args) {
        //调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化
        //也就是静态常量SingletonDemo1对象被创建
        SingletonDemo1.otherMethod();
        System.out.println(SingletonDemo1.getInstance());
        System.out.println(SingletonDemo1.getInstance());


        //1. 反射破坏单例
        try {
            reflection(SingletonDemo1.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void reflection(Class<SingletonDemo1> clazz) throws Exception {
        final Constructor<SingletonDemo1> constructor = clazz.getDeclaredConstructor();
        //暴力反射
        constructor.setAccessible(true);
        System.out.println("通过反射获取的实例" + constructor.newInstance());
    }
}
==================反射破坏单例===============
无参构造
otherMethods()
com.itheima.design_pattern.SingletonDemo1@330bedb4
com.itheima.design_pattern.SingletonDemo1@330bedb4
无参构造//反射调用构造器获取对象
通过反射获取的实例com.itheima.design_pattern.SingletonDemo1@2503dbd3
=====================预防反射破坏单例==================
无参构造
otherMethods()
com.itheima.design_pattern.SingletonDemo1@330bedb4
com.itheima.design_pattern.SingletonDemo1@330bedb4
java.lang.reflect.InvocationTargetException
Caused by: java.lang.RuntimeException: the instance is already exist
~~~





### 2.2 饿汉单例 (反序列化破坏单例+预防)

~~~java
package com.itheima.design_pattern;

import java.io.*;
import java.lang.reflect.Constructor;

/**
 * ClassName: SingletonDemo1
 * Description:饿汉式单例
 * date:2022/3/19
 *
 * @author fgcy
 * @since JDK 1.8
 */
//当希望该类的对象可以转为字节保存在磁盘中或进行网络传输时，实现序列化接口
public class SingletonDemo2 implements Serializable {
    private static final SingletonDemo2 INSTANCE = new SingletonDemo2();

    private SingletonDemo2() {

        //预防反射破坏单例
        if (INSTANCE != null) {
            throw new RuntimeException("the instance is already exist");
        }
        System.out.println("无参构造");
    }

    public static void otherMethod() {
        System.out.println("otherMethods()");
    }


    public static SingletonDemo2 getInstance() {
        return INSTANCE;
    }

    //预防反序列化破化单例
    public Object readResolve() {
        return INSTANCE;
    }
}

class TestSingleton {

    public static void main(String[] args) {
        //调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化
        //也就是静态常量SingletonDemo1对象被创建
        SingletonDemo1.otherMethod();
        System.out.println(SingletonDemo2.getInstance());
        System.out.println(SingletonDemo2.getInstance());

        //2.反序列化破坏单例
        try {
            serializable(SingletonDemo2.getInstance());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    //2.反序列化破坏单例
    private static void serializable(SingletonDemo2 instance) throws Exception {
        //字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中
        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
        final ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(instance);
        //字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中
        final ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
        //反序列化创建对象，不走构造器，直接从文件中生成
        System.out.println(ois.readObject());
    }

}

====================反序列化破坏单例======================
无参构造
otherMethods()
无参构造
com.itheima.design_pattern.SingletonDemo2@330bedb4
com.itheima.design_pattern.SingletonDemo2@330bedb4
com.itheima.design_pattern.SingletonDemo2@7b23ec81//不通过构造器获得新对象
====================预防反序列化破坏单例======================
无参构造
otherMethods()
无参构造
com.itheima.design_pattern.SingletonDemo2@330bedb4
com.itheima.design_pattern.SingletonDemo2@330bedb4
com.itheima.design_pattern.SingletonDemo2@330bedb4    
~~~





### 2.3 unSave破坏单例

~~~java
package com.itheima.design_pattern;

/**
 * ClassName: SingletonDemo1
 * Description:饿汉式单例
 * date:2022/3/19
 *
 * @author fgcy
 * @since JDK 1.8
 */
public class SingletonDemo3 {
    private static final SingletonDemo3 INSTANCE = new SingletonDemo3();

    public static void otherMethod() {
        System.out.println("otherMethods()");
    }

    public static SingletonDemo3 getInstance() {
        return INSTANCE;
    }
}


class TestSingleton {

    public static void main(String[] args) {
        //调用类的静态方法，使得SingletonDemo1这个类 加载、连接、初始化
        //也就是静态常量SingletonDemo1对象被创建
        SingletonDemo1.otherMethod();
        System.out.println(SingletonDemo3.getInstance());
        System.out.println(SingletonDemo3.getInstance());

        //unsave破坏单例
        try {
            final Object instance = getUnsafe().allocateInstance(SingletonDemo3.class);
            System.out.println(instance);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * ClassName: TestSingleton
     * Description:通过反射获取Unsave实例
     * date:2022/3/19
     *
     * @author fgcy
     * @since JDK 1.8
     */
    public static Unsafe getUnsafe() {
        try {
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            //因为 Unsafe 的 theUnsafe 字段是private 的，所以这里需要设置成可访问的
            field.setAccessible(true);
            //Unsafe 的这个属性 theUnsafe 是静态的所以这里的get参数就是null
            //因为get(Object obj))是获取某个实例的属性，类属性属于类不属于实例，实例只是共享
            Unsafe unsafe = (Unsafe) field.get(null);
            return unsafe;
        } catch (Exception e) {
        }
        return null;
    }
}
===============Unsave破坏单例（无解）========================
无参构造
otherMethods()
无参构造
com.itheima.design_pattern.SingletonDemo3@330bedb4
com.itheima.design_pattern.SingletonDemo3@330bedb4
com.itheima.design_pattern.SingletonDemo3@4b67cf4d
~~~







## 3.0 枚举饿汉式

### 3.1 认识枚举类

~~~java
package com.itheima.design_pattern;


public enum Sex {
    MALE, FEMALE;
}
----------------------------------
final class Sex extends Enum<Sex> {
    public static final Sex MALE;
    public static final Sex FEMALE;

    private Sex(String name, int ordinal) {
        super(name, ordinal);
    }

    static {
        MALE = new Sex("MALE", 0);
        FEMALE = new Sex("FEMALE", 1);
    }
    ........
}
~~~





### 3.2枚举类实现饿汉式单例

~~~java
package com.itheima.design_pattern;

import sun.misc.Unsafe;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;


//枚举实现饿汉式单例
public enum EnumSingletonTest {
    INSTANCE;

    //枚举的构造都是私有的，所以这里可以省略private，但不是包权限
    //java语言的内置规范.枚举类没有<init>无参构造
    EnumSingletonTest() {
        System.out.println("private EnumSingletonTest()");
    }

    public static void otherMethod() {
        System.out.println("public static void otherMethod()");
    }
    
    //需要重写toString；不然会打印 ”INSTANCE“
    @Override
    public String toString() {
        return this.getClass().getName() + "@" + Integer.toHexString(this.hashCode());
    }

    public static EnumSingletonTest getInstance() {
        return INSTANCE;
    }
}

class TestEnum {

    public static void main(String[] args) throws Exception {
        EnumSingletonTest.otherMethod();
        System.out.println(EnumSingletonTest.getInstance());
        System.out.println(EnumSingletonTest.getInstance());
        System.out.println("Unsave破坏单例" + getUnsafe().allocateInstance(EnumSingletonTest.class));
        
        //反序列化破坏单例
        //失败--》【ObjectInputStream会对枚举类做出识别，不会从文件中生成对象】
        serializable(EnumSingletonTest.getInstance());

        //反射破坏单例
        //失败
        // com.itheima.design_pattern.EnumSingletonTest.<init>()没有无参构造报错
        // Cannot reflectively create enum objects枚举类不能通过反射获取对象
        reflection(EnumSingletonTest.class);
    }


  
    public static Unsafe getUnsafe() {
        try {
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            //因为 Unsafe 的 theUnsafe 字段是private 的，所以这里需要设置成可访问的
            field.setAccessible(true);
            //Unsafe 的这个属性 theUnsafe 是静态的所以这里的get参数就是null
            //因为get(Object obj))是获取某个实例的属性，类属性属于类不属于实例，实例只是共享
            Unsafe unsafe = (Unsafe) field.get(null);
            return unsafe;
        } catch (Exception e) {
        }
        return null;
    }

    //通过反序列化获取EnumSingletonTest实例方法
    private static void serializable(EnumSingletonTest instance) throws Exception {
        //字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中
        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
        final ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(instance);
        //字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中
        //ObjectOutputStream会特殊处理枚举类，返回的式枚举类的实例，而不是文件中的字节数组生成的实例
        final ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
        System.out.println("反序列化破坏单例" + ois.readObject());
    }

    //通过反射获取EnumSingletonTest实例方法
    private static void reflection(Class<EnumSingletonTest> clazz) throws Exception {
        final Constructor<EnumSingletonTest> constructor = clazz.getDeclaredConstructor(String.class, int.class);
        //暴力反射
        constructor.setAccessible(true);
        //没有无参构造报错
//        System.out.println("通过反射获取的实例" + constructor.newInstance());
        //枚举类不能通过反射获取对象
//        System.out.println("通过反射获取的实例" + constructor.newInstance("OTHER", 3));
    }
}
=====================================================
private EnumSingletonTest()
public static void otherMethod()//运行静态方法前先跑静态代码块的内容，即先创建对象（饿汉式）
com.itheima.design_pattern.EnumSingletonTest@330bedb4
com.itheima.design_pattern.EnumSingletonTest@330bedb4
Unsave破坏单例com.itheima.design_pattern.EnumSingletonTest@4b67cf4d//可以破坏
反序列化破坏单例com.itheima.design_pattern.EnumSingletonTest@330bedb4//不可以破坏
~~~





## 4.0 懒汉单例



### 4.1 双检锁懒汉式

~~~java
package com.itheima.design_pattern;

import com.sun.org.apache.regexp.internal.RE;
import sun.misc.Unsafe;

import java.lang.reflect.Field;


public class Sluggard {

    //静态变量，属于类
	//private static Sluggard INSTANCE;
    //volatile 共享变量，可见性，有序性
    private static volatile Sluggard INSTANCE;


    private Sluggard() {
        System.out.println("private Sluggard()");
    }

    /*
     * 这种方式获取实例，没有线程安全性
     *
     * */
    public static Sluggard getInstance1() {
        if (INSTANCE == null) {
            //当多个线程第一次在还没有创建实例时就都来到这一步时，就会创建多个实例，破坏单例
            INSTANCE = new Sluggard();
        }
        return INSTANCE;
    }

    /*
     * 通过加锁的方式实现线程安全
     * 这里的锁对象时Sluggard.class
     * 当多个线程同时到达这个方法的外部时，只有一个线程可以获得锁进入方法，其他线程挂起
     * 当混进方法的线程执行完逻辑后，其他线程再竞争锁，进入方法，就会发现已有实例，不需要创建
     * 但这个方法有问题:每个线程调用该方法都要等待锁（即使此时，已有实例）
     * */
    public static synchronized Sluggard getInstance2() {
        if (INSTANCE == null) {
            INSTANCE = new Sluggard();
        }
        return INSTANCE;
    }

    /*
     * 解决上面方法的效率问题
     *
     * 双检锁懒汉式
     * */
    public static Sluggard getInstance() {
        //4.此时实例不为空，就不会存在线程不安全的问题
        if (INSTANCE == null) {
            //1.当多个线程第一次在还没有创建实例时就都来到这一步时
            //2.多个线程竞争锁
            synchronized (Sluggard.class) {
                //3.第一个竞争到锁的线程创建了实例，在外面等锁的线程，进来之后就不会创建实例
                if (INSTANCE == null) {
                    INSTANCE = new Sluggard();
                }
            }
        }
        return INSTANCE;
    }

    public static void otherMethod() {
        System.out.println(" public static void otherMethod()");
    }
}

class TestSingleton1 {

    public static void main(String[] args) {
        //先调用静态方法，如果是饿汉式，就会调用无参构造获取实例【加载 连接初 始化】
        Sluggard.otherMethod();
        System.out.println(Sluggard.getInstance());
        System.out.println(Sluggard.getInstance());
    }
}
===================================================================
public static void otherMethod()//懒汉式，调用静态方法没有触发初始化
private Sluggard()
com.itheima.design_pattern.Sluggard@330bedb4
com.itheima.design_pattern.Sluggard@330bedb4
~~~





### 4.2 为什么要添加valatile修饰符

~~~java
//主要是为了防止指令重排

//反编译字节码文件查看文件执行指令顺序
D:\learn\tencentClass\interview\ChanzPodcast\base\Project\out\production\one\com\itheima\design_pattern>javap -c -v -p Sluggard.class

 		17: new           #6                  // class com/itheima/design_pattern/Sluggard
        20: dup
        21: invokespecial #7                  // Method "<init>":()V
        24: putstatic     #5                  // Field INSTANCE:Lcom/itheima/design_pattern/Sluggard;
	//第17指令，创建对象；在堆内存中开辟出一块空间，根据Sluggard实例的成员变量和方法引用，计算出空间大小；【创建对象就是分配空间】
    //第21指令，调用构造器，为成员变量初始化(没有就赋默认值)
    //第24指令，给静态变量赋值，将创建好的Sluggard对象赋值给静态变量        
~~~

---

![image-20221023230321856](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232303927.png)

---



----

![image-20221023230413726](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202210232304585.png)

-----



- 小结

为什么懒汉单例没有线程安全问题
	静态成员变量在定义的同时赋值，这个赋值操作(给静态成员变量赋值)是会放在该类的静态代码块中；
	静态代码块中的线程安全，是由jvm负责的



### 4.3 内部类实现懒汉单例

- 代码实现

~~~java
package com.itheima.design_pattern;

import org.junit.Test;

/**
 * ClassName: InnerClassSingleton
 * Description:内部类实现懒汉单例
 * date:2022/3/20
 *
 * @author fgcy
 * @since JDK 1.8
 */
public class InnerClassSingleton {
	
    //私有构造
    private InnerClassSingleton() {
        System.out.println("private InnerClassSingleton()");
    }
	//静态方法
    private static void otherMethod() {
        System.out.println("private static void otherMethod()");
    }
	//内部类
    public static class InnerClass {
        //内部类可以访问外部类的所有成员（本类中）
        private static final InnerClassSingleton INSTANCE = new InnerClassSingleton();
    }

    public static InnerClassSingleton getInstance() {
        //静态内部类属于外部类，所以通过外部类类名调用，又因为是在本类，所以可以省略外部类类名
		//return InnerClassSingleton.InnerClass.INSTANCE;
        //碰到类的时候，就会加载静态代码块中的内容（又由于是在静态代码块中，线程是安全的）
        return InnerClass.INSTANCE;
    }


    public static void main(String[] args) {
        InnerClassSingleton.otherMethod();
        System.out.println("..........................");
        System.out.println(InnerClassSingleton.getInstance());
        System.out.println(InnerClassSingleton.getInstance());
    }
}
=======================================
private static void otherMethod()//InnerClassSingleton实例的创建在内部类中，这里只是调用了外部类的方法，没有碰到内部类，所以不会调用无参构造
..........................
private InnerClassSingleton()
com.itheima.design_pattern.InnerClassSingleton@330bedb4
com.itheima.design_pattern.InnerClassSingleton@330bedb4
~~~



## 5.0 jdk有哪些地方体现单例

- 双检锁懒汉式

~~~java
    System.java
	private static volatile Console cons = null;
     public static Console console() {
         if (cons == null) {
             synchronized (System.class) {
                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();
             }
         }
         return cons;
     }
~~~





- 饿汉式单例

~~~java
public class Runtime {
    //在静态代码块中实例
    private static Runtime currentRuntime = new Runtime();
	//提供一个对外访问的入口
    public static Runtime getRuntime() {
        return currentRuntime;
    }
	//私有构造
    private Runtime() {}
    
    //退出虚拟机的方法，非零代表异常退出
    public void exit(int status) {
      SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkExit(status);
        }
        Shutdown.exit(status);
    }
    //告诉虚拟机要做一次垃圾回收
    public native void gc();
~~~





- 内部类懒汉式单例

~~~java
 public class Collections {
	static class <E>{
        //内部类的内部类
        private static class EmptyNavigableSet<E> extends UnmodifiableNavigableSet<E>
            implements Serializable {
   			//防止反序列化破坏单例
            private Object readResolve(){ return EMPTY_NAVIGABLE_SET; }
        }
        
        //当有人碰到UnmodifiableNavigableSet时，才会触发初始化
        //EmptyNavigableSet的静态成员变量
        @SuppressWarnings("rawtypes")
        private static final NavigableSet<?> EMPTY_NAVIGABLE_SET =
                new EmptyNavigableSet<>();
    
     //UnmodifiableNavigableSet类返回EmptyNavigableSet单例的方法
     //EmptyNavigableSet的静态成员方法
    @SuppressWarnings("unchecked")
    public static <E> NavigableSet<E> emptyNavigableSet() {
        return (NavigableSet<E>) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;
    }   
}
     //Collections的静态成员方法
    @SuppressWarnings("unchecked")
    public static <E> SortedSet<E> emptySortedSet() {
        return (SortedSet<E>) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;
    }
 }
~~~





- 饿汉单例

~~~java
public class Collections {
    //在外部类中创建内部类对象不用带类名
    public static final Set EMPTY_SET = new EmptySet<>();
    
        @SuppressWarnings("unchecked")
        public static final <T> Set<T> emptySet() {
            return (Set<T>) EMPTY_SET;
     }
    
    //静态内部类（使用默认的公开无参构造，但外部类无法访问，私有的内部类）
    private static class EmptySet<E>{}
        
 }
~~~





- 枚举饿汉式

~~~java
public interface Comparator<T> {   
	public static <T extends Comparable<? super T>> Comparator<T> naturalOrder() {
        //调用枚举方法创造的实例
        return (Comparator<T>) Comparators.NaturalOrderComparator.INSTANCE;
    }  
}


class Comparators {
enum NaturalOrderComparator implements Comparator<Comparable<Object>> {
        INSTANCE;
    }
}
~~~



**JDK 中单例的体现**

* `Runtime `   体现了饿汉式单例
* `Console `  体现了双检锁懒汉式单例
* `Collections ` 中的 EmptyNavigableSet 内部类懒汉式单例
* `ReverseComparator.REVERSE_ORDER` 内部类懒汉式单例
* `Comparators.NaturalOrderComparator.INSTANCE` 枚举饿汉式单例

