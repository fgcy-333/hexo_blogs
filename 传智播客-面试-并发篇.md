---
title: 并发篇
date: 2022-08-23 21:05:38
tags:
- 院校帮-面试
categories: 
- 视频学习笔记
---

## java线程状态(六种)

<!--more-->

---

![image-20220823210402186](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823210402186.png)

---



1. `NEW状态` : new了一个Thread类，还没有调用start方法；只是一个java对象，还没有跟操作系统底层的线程关联起来；
2. `RUNNABLE状态`: 线程对象调用了sart方法，与真正的线程关联起来，内部的逻辑代码也会由操作系统交给cpu执行；
3. `TERMINATED状态 `:线程执行完全部的代码，意味着线程的生命周期结束；此时会释放底层真正的线程和相关资源；
4. `BLOCKED:状态`:当线程获取锁失败时，线程就会进入阻塞状态；当持该锁的线程进入终结状态，就会释放锁，同时唤醒所有被该锁锁住的线程，阻塞状态的线程获得锁后，就会进入	可运行状态，等待cpu执行
5. `WAITING状态` :当可运行状态，需要某个资源但得不到的时候，就会调用wait方法(不加时间)，先释放调锁，再进入无限等待状态；直到别人释放调该资源，并唤醒(notify、notifyAll)这个无限等待的线程,此时如果获得锁对象(或不用锁对象)就进入可运行状态，否则进入阻塞状态
6. `TIMED_WAITING状态` :由可运行状态通过调用wait(long)进入有时限等待，当时间到了（或时间没到但有人唤醒了），此时如果获得了锁对象，就直接转为可运行状态；



同理也可以调用sleep(long)实现，注意sleep(long)不释放锁，睡醒进入可运行状态。

- 代码实现

~~~java
package com.itheima.thread;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ClassName: NewRunnableTerminated
 * Description: NEW RUNNINABLE TERMINATED
 * date:2022/3/20
 *
 * @author fgcy
 * @since JDK 1.8
 */

public class NewRunnableTerminated {
    private static final Logger LOGGER =
            LoggerFactory.getLogger("NewRunnableTerminated.class");
    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        testNewRunnableTerminated();
    }

    private static void testNewRunnableTerminated() {
        Thread t1 = new Thread(() -> {
            LOGGER.debug("running.....");//3断点
        }, "t1");
        LOGGER.debug("t1-state:{}", t1.getState());//1
        t1.start();
        LOGGER.debug("t1-state:{}", t1.getState());//2

        LOGGER.debug("t1-state:{}", t1.getState());//4断点

    }
}
========================================================
2022-03-20 14:44:42.453 [DEBUG] NewRunnableTerminated.class [main] : t1-state:NEW
2022-03-20 14:44:42.493 [DEBUG] NewRunnableTerminated.class [main] : t1-state:RUNNABLE
2022-03-20 14:44:57.566 [DEBUG] NewRunnableTerminated.class [t1] : running.....
2022-03-20 14:45:07.726 [DEBUG] NewRunnableTerminated.class [main] : t1-state:TERMINATED//控制t1线程跑完，再回到mian线程输出t1状态
~~~

~~~JAVA
package com.itheima.thread;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ClassName: NewRunnableTerminated
 * Description: NEW RUNNINABLE BLOCKED TERMINATED
 * date:2022/3/20
 *
 * @author fgcy
 * @since JDK 1.8
 */

public class NewRunnableTerminated {
    private static final Logger LOGGER =
            LoggerFactory.getLogger("NewRunnableTerminated.class");
    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        testBlocked();
    }

    private static void testBlocked() {
        Thread t2 = new Thread(() -> {
            LOGGER.debug("before sync");//3 输出before sync 此时发现没有锁对象，进入阻塞
            synchronized (LOCK) {
                LOGGER.debug("in sync");//6 输出in sync
            }
        }, "t2");
        LOGGER.debug("t2-state:{}", t2.getState());//0 t2-state:NEW
        t2.start();
        LOGGER.debug("t2-state:{}", t2.getState());//1 t2-state:RUNNABLE
        synchronized (LOCK) {
            LOGGER.debug("t2-state:{}", t2.getState());//2 控制main线程先获取锁对象 4输出t2-state:BLOCKED
        }
        LOGGER.debug("t2-state:{}", t2.getState());//5控制main线程释放锁 7输出 : t2-state:RUNNABLE
        LOGGER.debug("t2-state:{}", t2.getState());//8 t2-state:TERMINATED
    }
}
=====================================================
2022-03-20 15:09:19.828 [DEBUG] NewRunnableTerminated.class [main] : t2-state:NEW
2022-03-20 15:09:23.466 [DEBUG] NewRunnableTerminated.class [main] : t2-state:RUNNABLE
2022-03-20 15:09:32.477 [DEBUG] NewRunnableTerminated.class [t2] : before sync
2022-03-20 15:09:36.481 [DEBUG] NewRunnableTerminated.class [main] : t2-state:BLOCKED
2022-03-20 15:09:43.454 [DEBUG] NewRunnableTerminated.class [t2] : in sync
2022-03-20 15:09:51.850 [DEBUG] NewRunnableTerminated.class [main] : t2-state:RUNNABLE
2022-03-20 15:10:01.585 [DEBUG] NewRunnableTerminated.class [main] : t2-state:TERMINATED
~~~

~~~java
package com.itheima.thread;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ClassName: NewRunnableTerminated
 * Description: NEW RUNNINABLE WAITING BLOCKED TERMINATED
 * date:2022/3/20
 *
 * @author fgcy
 * @since JDK 1.8
 */

public class NewRunnableTerminated {
    private static final Logger LOGGER =
            LoggerFactory.getLogger("NewRunnableTerminated.class");
    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        testWaiting();
    }
    private static void testWaiting() {
        Thread t2 = new Thread(() -> {
            //6 t2线程发现没有锁对象，阻塞
            synchronized (LOCK) {
                LOGGER.debug("before waiting.....");//2 before waiting.....
                try {
                    LOCK.wait();  //3 释放锁 进入无限等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t2");
        LOGGER.debug("t2-state:{}", t2.getState());//t2-state:NEW
        t2.start();
        LOGGER.debug("t2-state:{}", t2.getState());//1 t2-state:RUNNABLE
        synchronized (LOCK) {
            LOGGER.debug("t2-state:{}", t2.getState());//4 获得锁  t2-state:WAITING
            LOCK.notify();//5 唤醒t2线程
            LOGGER.debug("t2-state:{}", t2.getState());//7 t2-state:BLOCKED
        }
        LOGGER.debug("t2-state:{}", t2.getState());//main线程释放锁，t2进入可运行状态 t2-state:RUNNABLE
        LOGGER.debug("t2-state:{}", t2.getState());//t2线程跑完 t2-state:TERMINATED
    }
}
=================================================
2022-03-20 15:28:55.319 [DEBUG] NewRunnableTerminated.class [main] : t2-state:NEW
2022-03-20 15:29:08.539 [DEBUG] NewRunnableTerminated.class [main] : t2-state:RUNNABLE
2022-03-20 15:29:28.980 [DEBUG] NewRunnableTerminated.class [t2] : before waiting.....
2022-03-20 15:29:37.246 [DEBUG] NewRunnableTerminated.class [main] : t2-state:WAITING
2022-03-20 15:29:54.372 [DEBUG] NewRunnableTerminated.class [main] : t2-state:BLOCKED
2022-03-20 15:30:04.711 [DEBUG] NewRunnableTerminated.class [main] : t2-state:RUNNABLE
2022-03-20 15:30:13.273 [DEBUG] NewRunnableTerminated.class [main] : t2-state:TERMINATED
~~~

~~~java
package com.itheima.thread;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ClassName: NewRunnableTerminated
 * Description: NEW RUNNINABLE TIMED-WAITING BLOCKED TERMINATED
 * date:2022/3/20
 *
 * @author fgcy
 * @since JDK 1.8
 */

public class NewRunnableTerminated {
    private static final Logger LOGGER =
            LoggerFactory.getLogger("NewRunnableTerminated.class");
    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        testTimed();
    }

    private static void testTimed() {
        Thread t2 = new Thread(() -> {
            synchronized (LOCK) {
                LOGGER.debug("before wait(10000000)");//1 before wait(10000000)
                try {
                    LOCK.wait(10100000);//3 进入有限等待（唤醒main，释放锁）
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t2");
        LOGGER.debug("t2-state:{}", t2.getState());//0 t2-state:NEW
        t2.start();
        LOGGER.debug("t2-state:{}", t2.getState());//2 t2-state:RUNNABLE
        synchronized (LOCK) {
            LOGGER.debug("t2-state:{}", t2.getState());//4 : t2-state:TIMED_WAITING
            LOCK.notify();//5 唤醒t2线程，t2没有锁进入阻塞状态
            LOGGER.debug("t2-state:{}", t2.getState());//6  t2-state:BLOCKED
        }
        LOGGER.debug("t2-state:{}", t2.getState());// 7 释放锁 t2进入可运行状态  t2-state:RUNNABLE
        LOGGER.debug("t2-state:{}", t2.getState());//8 控制t2线程跑完 t2-state:TERMINATED
    }
}
===============================================
2022-03-20 16:11:47.549 [DEBUG] NewRunnableTerminated.class [main] : t2-state:NEW
2022-03-20 16:12:03.106 [DEBUG] NewRunnableTerminated.class [t2] : before wait(10000000)
2022-03-20 16:12:12.191 [DEBUG] NewRunnableTerminated.class [main] : t2-state:RUNNABLE
2022-03-20 16:12:28.220 [DEBUG] NewRunnableTerminated.class [main] : t2-state:TIMED_WAITING
2022-03-20 16:12:39.316 [DEBUG] NewRunnableTerminated.class [main] : t2-state:BLOCKED
2022-03-20 16:12:54.137 [DEBUG] NewRunnableTerminated.class [main] : t2-state:RUNNABLE
2022-03-20 16:13:01.379 [DEBUG] NewRunnableTerminated.class [main] : t2-state:TERMINATED
~~~







## 操作系统层面（5种）

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-20_16-22-35.png)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-20_16-45-42.png)

---



新建状态：进程创建的过程中，所需的资源尚不能得到满足，此时创建工作尚未完成，进程无法被调度执行，进程此时就处于创建状态。
就绪状态：此时进程已经分配好除CPU外的所有必要资源，只需获得CPU的调度
运行状态：进程已经获得CPU并且正在执行中
阻塞状态：处于此状态的进程是因为在执行的过程中由于发生某种需要等待的事件（I/O请求、申请缓存失败、等待接收数据等），而暂时无法继续执行
终止状态：进程正常运行结束或者出现导致进程终止的错误，或是被OS所终结，或是被父进程终结，则进入终止状态



- 注意

java中的RUNNABLE状态包括了就绪、运行、阻塞I/O;也可以说是java的RUNNABLE状态无法区分操作系统中的这几种状态。



## 线程池的核心参数

![image-20220823205738853](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823205738853.png)

corePoolSize:核心线程数量(可以为零)
maximumPoolSize:线程池的最大线程数目(核心线程+救急线程)
keepAliveTime：救急线程在停止运行后，最大的存活时间
unit:最大存活时间的单位
workQueue：用于接收并存放任务的队列 
handler:当所有线程在忙，任务队列已满，此时再来一个任务，要怎么处理（拒绝策略）



- 代码实现

~~~java
package com.itheima.thread;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * ClassName: ThreadPoolDemo <br/>
 * Description: <br/>
 * date: 2022/3/20 19:02<br/>
 *
 * @author fgcy<br />
 * @since JDK 1.8
 */
public class ThreadPoolDemo {
    public static void main(String[] args) {
        final AtomicInteger c = new AtomicInteger(1);
/*        ExecutorService pool = new ThreadPoolExecutor(2, 3, 0,
                TimeUnit.SECONDS, new ArrayBlockingQueue<>(2), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
                */

        // new ThreadPoolExecutor.DiscardOldestPolicy()当全部线程在忙，任务队列已满，此时再添加一个任务，丢弃任务队列中，存在时间最长的
        //new ThreadPoolExecutor.DiscardPolicy()当全部线程在忙，任务队列已满，此时再添加一个任务，丢弃这个刚加入的任务
        //new ThreadPoolExecutor.CallerRunsPolicy()当全部线程在忙，任务队列已满，此时再添加一个任务，由提交任务的线程执行
        //new ThreadPoolExecutor.AbortPolicy()当全部线程在忙，任务队列已满，此时再添加一个任务，外抛异常
        ExecutorService pool = new ThreadPoolExecutor(2, 3, 0,
                TimeUnit.SECONDS, new ArrayBlockingQueue<>(2), r -> new Thread(r, "myThread" + c.getAndIncrement())
                , new ThreadPoolExecutor.AbortPolicy());

        try {
            /*
            * 什么时候创建救急线程？
            *   核心线程在忙，任务队列已满，此时再提交一个任务，就会创建救急线程处理该任务
            * 什么时候使用拒绝策略？
            *   当全部线程在忙，任务队列已满，此时再添加一个任务
            * */
            pool.submit(new Taskk(100000L, "1"));
            pool.submit(new Taskk(100000L, "2"));
            pool.submit(new Taskk(100000L, "3"));
            pool.submit(new Taskk(100000L, "4"));
            pool.submit(new Taskk(1000L, "13224"));
//            pool.submit(new Taskk(1000L, "6"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Taskk implements Callable<String> {
    private Long milliseconds;
    private String name;

    public Taskk(Long milliseconds, String name) {
        this.milliseconds = milliseconds;
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        System.out.println(Thread.currentThread().getName() + "正在跑任务" + name);
        Thread.sleep(milliseconds);
        System.out.println("任务" + name + "结束");
        return "success";
    }
}
==========================================================
myThread2正在跑任务2
myThread3正在跑任务13224
myThread1正在跑任务1
任务13224结束
myThread3正在跑任务3
~~~

~~~java
package com.itheima.thread;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;


public class ThreadDemo {
    public static void main(String[] args) {
        final AtomicInteger c = new AtomicInteger(1);
        ExecutorService executorService = new ThreadPoolExecutor(3, 5, 4
                , TimeUnit.SECONDS, new ArrayBlockingQueue<>(5),
                r -> new Thread(r, "myThread" + c.getAndIncrement())
                , new ThreadPoolExecutor.CallerRunsPolicy());

        executorService.execute(new MyRunnable("1", 1000000L));//1
        executorService.execute(new MyRunnable("2", 1000000L));//2
        executorService.execute(new MyRunnable("3", 1000000L));//3 三个核心线程在忙
        executorService.execute(new MyRunnable("4", 1000000L));//4
        executorService.execute(new MyRunnable("5", 1000000L));//5
        executorService.execute(new MyRunnable("6", 1000000L));//6
        executorService.execute(new MyRunnable("7", 1000000L));//7
        executorService.execute(new MyRunnable("8", 1000000L));//8 任务队列可以存放五个任务 【此时·还不会创建临时线程】
        executorService.execute(new MyRunnable("9", 1000000L));//9 此时核心线程在忙，任务队列已满，未达到最大线程数量，再来一个线程就开启临时线程
        //10 上面在满的情况下加入了一个，然后又处理了一个；相当于还是处于满的状态；此时再来一个线程，判断核心线程在忙？，任务队列已满？，未达到最大线程数量？创建一个新的临时线程
        executorService.execute(new MyRunnable("10", 1000000L));//10
        //11 java.util.concurrent.RejectedExecutionException
        executorService.execute(new MyRunnable("11", 1000000L));//11 此时 所有线程在忙，任务队列已满，再来一个任务，就会采用线程池配置的策略（由提交该任务的线程执行！！）
        /*
         * 这行代码无法执行，上面抛异常了；但jvm没有挂，说明线程池有捕获异常的机制；
         * try catch 中try语句块出错后的代码无法执行，
         * */
        executorService.shutdown();//等待所有任务执行完毕后，关闭
        executorService.shutdownNow();//即时任务没有完成，也要立即关闭
    }
}

class MyRunnable implements Runnable {
    private String name;
    private Long milliseconds;

    public MyRunnable(String name, Long milliseconds) {
        this.name = name;
        this.milliseconds = milliseconds;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "正在跑任务" + name);
        try {
            Thread.sleep(milliseconds);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("任务" + name + "结束");
    }
}
======================================================
myThread1正在跑任务1
myThread5正在跑任务10
myThread4正在跑任务9
main正在跑任务11
myThread3正在跑任务3
myThread2正在跑任务2
~~~

## sleep vs wait

- 共同点

wait()、wait(long)、sleep(long)的效果都是让当前线程放弃cpu的使用权（让出cpu），进入阻塞状态(操作系统的阻塞)，java的无限等待或有限等待



- 方法归属不同

sleep是Thread的静态方法，直接那类名调
wait()、wait(long)属于Object类的成员方法，每个实例都有



- 醒来的时机不同

1. 执行sleep(long)、wait(long)方法的线程，会在等待相应的毫秒值后醒来
2. wait()、wait(long)方法可以被锁对象的notify()、notifyAll()方法唤醒，wait()如果一直没有人唤醒，就会一直等下去
3. 他们都可以被打断而唤醒：拿到调用wait或sleep方法的线程，调用Thread.currentThread().interrupt()，让等待的线程外抛一个打断异常，从而唤醒线程



- 锁特征不同

1. wait方法的调用必须先获取wait对象的锁(必须配合锁一起使用)，而sleep则无此限制
2. wait方法执行后会释放锁对象，允许其他线程获得该锁对象；（让出锁对象，让出cpu）
3. sleep方法如果在synchronized代码块中执行，并不会释放锁对象；（让出cpu，不让出锁对象）



- 代码实现

~~~java
package com.itheima.thread;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class WaitVsSleep {
    private static final Logger LOGGER = LoggerFactory.getLogger("WaitVsSleep.class");

    private static final Object LOCK = new Object();

    public static void main(String[] args) {
//        illegalWait();
//        waiting();
//        sleeping();
        interrupted();
    }


    private static void illegalWait() {
        try {
            //java.lang.IllegalMonitorStateException
            //wait方法要配合锁对象一起使用
            //LOCK只是一个普通的对象，只有当其放在synchronized括号中，才成为锁对象
            //LOCK.wait();
            //此时LOCK成为锁对象
            synchronized (LOCK) {
                LOCK.wait();
            }


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void waiting() {
        Thread t1 = new Thread(() -> {
            synchronized (LOCK) {
                try {
                    LOGGER.debug("waiting....");
                    //3让出cpu，让出锁
                    LOCK.wait(5000L);
                    //等待结束，并得到锁，跑完线程
                    LOGGER.debug("stop waiting....");
                } catch (Exception e) {
                    LOGGER.debug("interrupted....");
                    e.printStackTrace();
                }
            }
        }, "t1");
        //1.main线程调用t1线程
        t1.start();
        try {
            //2确保t1线程得到锁
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //4获取锁
        synchronized (LOCK) {
            LOGGER.debug("other.....");
        }
        //6结束
    }

    private static void sleeping() {
        Thread t1 = new Thread(() -> {
            synchronized (LOCK) {
                try {
                    //3 输出
                    LOGGER.debug("slepping......");
                    //4 让出cpu，持有锁5s
                    Thread.sleep(5000L);
                    //5 5秒后输出，跑完程序，释放锁
                    LOGGER.debug("stop slepping......");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, "t1");
        //1 main调用t1线程
        t1.start();
        try {
            //2 main先睡100ms确保t1线程获取锁
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //6 得到锁
        synchronized (LOCK) {
            //7 输出
            LOGGER.debug("other......");
        }
    }

    private static void interrupted() {
        Thread t1 = new Thread(() -> {
            synchronized (LOCK) {
                try {
                    //3 输出
                    LOGGER.debug("slepping......");
                    //4 让出cpu，持有锁 想要等待5秒
                    //Thread.sleep(5000L);
                    //LOCK.wait();
                    // LOCK.wait(10000);
                    LOGGER.debug("stop slepping......");
                } catch (Exception e) {
                    LOGGER.debug("interrupted...");
                    e.printStackTrace();
                }
            }
        }, "t1");
        //1 main调用t1线程
        t1.start();
        try {
            //2 main先睡100ms确保t1线程获取锁
            Thread.sleep(100);
            //6 中断打断sleep、wait 连5秒都不给他
            t1.interrupt();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}

================ waiting()======================
2022-03-20 23:20:46.883 [DEBUG] WaitVsSleep.class [t1] : waiting....
2022-03-20 23:20:46.985 [DEBUG] WaitVsSleep.class [main] : other.....
2022-03-20 23:20:51.889 [DEBUG] WaitVsSleep.class [t1] : stop waiting....
================ sleeping()======================  
2022-03-20 23:21:33.892 [DEBUG] WaitVsSleep.class [t1] : slepping......
2022-03-20 23:21:38.895 [DEBUG] WaitVsSleep.class [t1] : stop slepping......
2022-03-20 23:21:38.895 [DEBUG] WaitVsSleep.class [main] : other......
================ interrupted()======================  
2022-03-20 23:28:37.489 [DEBUG] WaitVsSleep.class [t1] : slepping......
2022-03-20 23:28:37.593 [DEBUG] WaitVsSleep.class [t1] : interrupted...
java.lang.InterruptedException
	at java.lang.Object.wait(Native Method)
	at com.itheima.thread.WaitVsSleep.lambda$interrupted$0(WaitVsSleep.java:27)
	at java.lang.Thread.run(Thread.java:748)
进程已结束，退出代码为 0    
~~~





## lock vs synchronized

- 语法层面

1. synchronized是java中的关键字，是用C++实现的，源码在JVM中（java中的内置锁）
2. Lock是接口，源码在jdk中可以找到，用java语言实现的
3. 使用synchronized时，退出同步代码块会自动释放锁，而是用Lock时，需要手动释放锁unlock方法 建议在finally块中释放锁



- 功能层面

1. 二者都属于悲观锁，都具备互斥(多个线程争抢同一把锁，在同一时刻只能有一个线程可以获取)、同步(一个线程所需要的数据来源于另一个线程的结果，这种一个线程等待另一	个线程执行完毕，再进行后续操作的情况称为同步；synchronized通过wait、notify实现同步；lock通过await，single实现同步)、锁重入(对同一个对象加多道锁)。
2. Lock提供了许多synchronized不具备的功能，例如：获取等待状态(可以知到对于某个锁对象来说处于阻塞状态的线程有哪些，可以知到对于某个锁对象来说处于等待状态的		线程有哪些)、公平锁(多个争抢锁，先到先得；非公平锁：多个线程争抢锁，可以插队获得，效率更高；Lock两种都支持)、可打断(等不到锁，就把线程打断了，不能一直		无限等待)、可超时(可以设置超时时间，在规定时间内没能获取锁，就放弃获取该锁)、多条件变量。
3. Lock有适合不同场景的实现，如ReentrantLock、ReentrantReadWriteLock。



- 性能层面

在没有竞争时，synchronized做了很多优化，如偏向锁，轻量级锁，性能不错
在竞争激烈时，Lock的实现通常可以提供更好的性能



## 可重入锁理解

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;


public class ReentratLockDemo {
    static final Logger LOGGER = LoggerFactory.getLogger("ReentratLockDemo.class");
    public static final ReentrantLock LOCK = new ReentrantLock(false);
    //用作同步操作
    //通过ReentrantLock创建的两个等待队列，当线程在运行代码时，发现条件不满足，就会把自己停止，进入等待队列 waiting queue（单链表）
    public static Condition c1 = LOCK.newCondition();
    public static Condition c2 = LOCK.newCondition();

    public static void main(String[] args) throws Exception {
        System.out.println(LOCK);
        //ReentrantLock里面有一个变量owner，记录自己是被哪个线程持有
        // 有一个state变量用于记录被上锁的次数
        // (可重入锁，在该程序中可以进行多次上锁，没上一次锁，state的值就会加一，而通过该锁对象的unlock方法可以解锁一次，state减一，当state值为零时，代表该锁没有被占有)
        //当抢不到该锁的线程就会进入该锁的阻塞队列中blocked queue单链表
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
        }, "t1").start();
		//保证进入阻塞队列的线程是t1 t2 t3 t4
        Thread.sleep(100);
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
        }, "t2").start();

        Thread.sleep(100);
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
        }, "t3").start();

        Thread.sleep(100);
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
        }, "t4").start();
    }
}
======================================================
java.util.concurrent.locks.ReentrantLock@6a2bcfcb[Unlocked]
13:53:53.151 [t1] DEBUG ReentratLockDemo.class - t1 using lock
13:54:07.188 [t2] DEBUG ReentratLockDemo.class - t2 using lock
13:54:19.461 [t3] DEBUG ReentratLockDemo.class - t3 using lock
13:54:29.408 [t4] DEBUG ReentratLockDemo.class - t4 using lock
~~~

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-23_13-57-05.png)

---



## 公平锁 & 非公平锁

- 代码体现

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;


public class ReentratLockDemo {
    static final Logger LOGGER = LoggerFactory.getLogger("ReentratLockDemo.class");
    public static final ReentrantLock LOCK = new ReentrantLock(false);
    //用作同步操作
    //通过ReentrantLock创建的两个等待队列，当线程在运行代码时，发现条件不满足，就会把自己停止，进入等待队列 waiting queue（单链表）
    public static Condition c1 = LOCK.newCondition();
    public static Condition c2 = LOCK.newCondition();

    static volatile boolean stop = false;

    public static void main(String[] args) throws Exception {
        System.out.println(LOCK);
        //ReentrantLock里面有一个变量owner，记录自己是被哪个线程持有
        // 有一个state变量用于记录被上锁的次数
        // (可重入锁，在该程序中可以进行多次上锁，没上一次锁，state的值就会加一，而通过该锁对象的unlock方法可以解锁一次，state减一，当state值为零时，代表该锁没有被占有)
        //当抢不到该锁的线程就会进入该锁的阻塞队列中blocked queue单链表
        //按照阻塞队列的入队顺序执行线程
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
            sleep1s();
            LOCK.unlock();
        }, "t1").start();

        Thread.sleep(100);
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
            sleep1s();
            LOCK.unlock();
        }, "t2").start();

        Thread.sleep(100);
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
            sleep1s();
            LOCK.unlock();
        }, "t3").start();

        Thread.sleep(100);
        new Thread(() -> {
            LOCK.lock();
            LOGGER.debug(Thread.currentThread().getName() + " using lock");
            sleep1s();
            LOCK.unlock();
        }, "t4").start();

        //没能创建一个打乱公平的线程
//        LOGGER.debug(flag + "");

        while (!stop) {
            new Thread(() -> {
                try {
                    //尝试获得锁，但只会等10秒，10秒后就不等了，返回false
                    //上面直接调用LOCK.lock();就会死等
                    //这个获取不到锁也不会进入阻塞队列，在非公平的情况下，不进入阻塞队列中的线程有机会随机插在有顺序的阻塞队列中的线程里面(外面)
                    //这里记住是10毫秒，太长，就会产生很多线程；因为在没有收到stop标志位改变时，就会一直创建线程，即使这些线程中有一个是创建成功的
                    final boolean b = LOCK.tryLock(10, TimeUnit.MILLISECONDS);

                    //这个无参tryLock无论ReentrantLock的参数是真还是假，哪个不进入阻塞队列中的线程会按照不公平的来
//                    final boolean b = LOCK.tryLock();
                    //抢到锁
                    if (b) {
                        LOGGER.debug(Thread.currentThread().getName() + " using lock");
                        stop = true;
                        sleep1s();
                        LOCK.unlock();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }, "others").start();
        }
    }

    private static void sleep1s() {
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
==============有参tryLock====== new ReentrantLock(false)=============
java.util.concurrent.locks.ReentrantLock@c4437c4[Unlocked]
15:12:22.267 [t1] DEBUG ReentratLockDemo.class - t1 using lock
15:12:23.270 [t2] DEBUG ReentratLockDemo.class - t2 using lock
15:12:24.278 [others] DEBUG ReentratLockDemo.class - others using lock//后到先来
15:12:25.291 [t3] DEBUG ReentratLockDemo.class - t3 using lock
15:12:26.303 [t4] DEBUG ReentratLockDemo.class - t4 using lock
==============有参tryLock====== new ReentrantLock(true)=============
java.util.concurrent.locks.ReentrantLock@c4437c4[Unlocked]
15:16:50.291 [t1] DEBUG ReentratLockDemo.class - t1 using lock
15:16:51.291 [t2] DEBUG ReentratLockDemo.class - t2 using lock
15:16:52.291 [t3] DEBUG ReentratLockDemo.class - t3 using lock
15:16:53.291 [t4] DEBUG ReentratLockDemo.class - t4 using lock
15:16:54.760 [others] DEBUG ReentratLockDemo.class - others using lock//按公平的来，先到先得
==============无参tryLock====== new ReentrantLock(true)=============
java.util.concurrent.locks.ReentrantLock@c4437c4[Unlocked]
15:18:12.650 [t1] DEBUG ReentratLockDemo.class - t1 using lock
15:18:13.651 [others] DEBUG ReentratLockDemo.class - others using lock//后到先来
15:18:14.667 [t2] DEBUG ReentratLockDemo.class - t2 using lock
15:18:15.667 [t3] DEBUG ReentratLockDemo.class - t3 using lock
15:18:16.667 [t4] DEBUG ReentratLockDemo.class - t4 using lock
~~~

## lock条件变量演示

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;


public class ReentratLockDemo1 {
    static final Logger LOGGER = LoggerFactory.getLogger("fgcy");
    public static final ReentrantLock LOCK = new ReentrantLock(false);
    //用作同步操作
    //通过ReentrantLock创建的两个等待队列，当线程在运行代码时，发现条件不满足，就会把自己停止(让出锁和cpu)，进入等待队列 waiting queue（单链表）
    // 当被人唤醒或等待时间到了就会离开condition队列，当没有获得锁时，在阻塞队列尾部插入自己的线程(等获得锁后，就会从上次终止的位置开始执行)
    public static Condition c1 = LOCK.newCondition();
    public static Condition c2 = LOCK.newCondition();

    static volatile boolean stop = false;

    public static void main(String[] args) throws Exception {
        //人为控制顺序 1
        new Thread(() -> {
            try {
                LOCK.lock();
                LOGGER.debug(Thread.currentThread().getName() + " using lock");
                LOGGER.debug(Thread.currentThread().getName() + " before into c1 Condition");
                //进入condition队列(释放掉锁和cpu)
                if (true) c1.await();
                LOGGER.debug(Thread.currentThread().getName() + " getout from c1 Condition and getout from blocked queue");
                LOCK.unlock();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "t1").start();

        //人为控制顺序 2
        Thread.sleep(100);
        new Thread(() -> {
            try {
                LOCK.lock();
                LOGGER.debug(Thread.currentThread().getName() + " using lock");
                LOGGER.debug(Thread.currentThread().getName() + " before into c2 Condition");
                //在c1 condition queue中随机获取一个线程唤醒
                c1.signal();
                //进入condition队列(释放掉锁和cpu)
                if (true) c2.await();
                LOGGER.debug(Thread.currentThread().getName() + " getout from c2 Condition and getout from blocked queue");
                LOCK.unlock();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "t2").start();

        //人为控制顺序 3
        Thread.sleep(100);
        new Thread(() -> {
            try {
                LOCK.lock();
                LOGGER.debug(Thread.currentThread().getName() + " using lock");
                LOGGER.debug(Thread.currentThread().getName() + " before into c2 Condition");
                //进入condition队列(释放掉锁和cpu)
                if (true) c2.await();
                LOGGER.debug(Thread.currentThread().getName() + " getout from c2 Condition and getout from blocked queue");
                LOCK.unlock();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "t3").start();
        //人为控制顺序 4
        Thread.sleep(100);
        new Thread(() -> {
            try {
                LOCK.lock();
                LOGGER.debug(Thread.currentThread().getName() + " using lock");
                //唤醒condition c2 queue中的全部线程(有没有获得锁的情况下，按照condition c2 queue中顺序进入blocked queue；在获得锁对象情况下，按condition c2 queue中顺序执行)
                c2.signalAll();
                //进入condition队列(释放掉锁和cpu)
                LOGGER.debug(Thread.currentThread().getName() + " end");
                LOCK.unlock();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "t4").start();
    }
}
===================================================================
16:39:48.707 [t1] DEBUG fgcy - t1 using lock
16:39:48.709 [t1] DEBUG fgcy - t1 before into c1 Condition
16:39:48.709 [t2] DEBUG fgcy - t2 using lock
16:39:48.709 [t2] DEBUG fgcy - t2 before into c2 Condition
16:39:48.709 [t3] DEBUG fgcy - t3 using lock
16:39:48.709 [t3] DEBUG fgcy - t3 before into c2 Condition
16:39:48.709 [t4] DEBUG fgcy - t4 using lock
16:39:48.709 [t4] DEBUG fgcy - t4 end
16:39:48.709 [t1] DEBUG fgcy - t1 getout from c1 Condition and getout from blocked queue
16:39:48.710 [t2] DEBUG fgcy - t2 getout from c2 Condition and getout from blocked queue
16:39:48.710 [t3] DEBUG fgcy - t3 getout from c2 Condition and getout from blocked queue
~~~

## volatile能否保证线程安全



### 线程安全要考虑的三个因素

1. 可见性: 一个线程对共享变量做出了修改，其他的线程要能看到最新的结果
2. 有序性: 一个线程内代码必须按编写顺序执行(指令重排序会破坏)
3. 原子性:一个线程内的多行代码以一个整体执行，期间不能被其他线程的代码插队





### 关键字volatile

volatile关键字只能保证共享变量的有序性和可见性，不能保证原子性



#### 原子性举例

- 对字节码文件进行反编译

~~~
D:\learn\tencentClass\interview\ChanzPodcast\base\Project\one\target\classes\com\itheima\lock>javap -p -v VolatitleDemo1.class
~~~

- add方法中的一行java代码对应的指令

~~~java
  private static void add5();
         0: getstatic     #9                  // Field N:I //获取常量N的值
         3: iconst_5                          //准备一个数字五
         4: iadd							  //将获取到的值加五
         5: putstatic     #9                  // Field N:I//将计算到的值给到N
         8: return						      //结束方法
~~~

- substract方法中的一行java代码对应的指令

~~~java
 private static void subtract5();
         0: getstatic     #9                  // Field N:I////获取常量N的值
         3: iconst_5						  //准备一个数字五
         4: isub							  //将获取到的值加五
         5: putstatic     #9                  // Field N:I//将计算到的值给到N
         8: return							 //结束方法
~~~

- 原子性例子

~~~java
t1 10         
0: getstatic 10    
                 t2 10
                 0: getstatic   10               
                 3: iconst_5						  
                 4: isub		10+5					 
                 5: putstatic     15        
                 8: return	         
         
3: iconst_5
4: isub        10-5
5: putstatic    5        
8: return
~~~

在多线程下发生指令交错的情况，就可能产生意料之外的结果



 - 解决:

 	1. 保证指令是原子的
 	2. 加锁，将多条指令用锁锁起来，作为同一条指令（一个整体）
 	
 		3. CAS来实现无锁原子操作



- 代码体现

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VolatitleDemo1 {
    static volatile int N = 10;
    static final Logger fgcy = LoggerFactory.getLogger("fgcy");

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            add5();
        }).start();


        new Thread(() -> {
            subtract5();
        }).start();

        Thread.sleep(1);
        fgcy.debug(String.valueOf(N));//7 输出N
    }

    private static void subtract5() {
        //这虽然一行命令不是一个原子操作，他包含多个命令
        //N -= 5;
        //模拟等价操作
        int b = N;//1 拿到值 10
        b -= 5;//3 用b减五
        N = b;// 4 改变静态成员
    }

    private static void add5() {
        //这虽然一行命令不是一个原子操作，他包含多个命令
        //N += 5;
        int b = N;//2 拿到值 10
        b += 5; //5 用b加五
        N = b;// 6 改变静态成员
    }
}
==============================================
21:00:19.643 [main] DEBUG fgcy - 15
~~~







#### 可见性例子

- 问题引出

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VolatitleDemo2 {
    static boolean stop = false;
    static final Logger fgcy = LoggerFactory.getLogger("fgcy");

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //等0.1秒后将stop改为true
            //输出stopping .....并统计次数
            stop = true;
            fgcy.debug("modify stop to true...");
        }).start();
        fool();
    }

    private static void fool() {
        int i = 0;
        while (!stop) {
            i++;
        }
        fgcy.debug("stopping ....." + i);
    }
}
================================================
21:43:14.988 [Thread-0] DEBUG fgcy - modify stop to true...//循环还没有结束，主线程在一直死循环 
    
~~~







问题： 一个线程对共享变量做出修改，另一个线程没能读取到最新的值

---

![image-20220823205351778](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823205351778.png)

---





1. JIT（java的即时编译器）：JVM的组成部分，主要是对热点代码进行优化解析。

2. 热点代码:频繁调用的方法，包括反复调用的循环。

3. java代码会转化为字节码指令，然后通过解释器将字节码文件逐行转化为机器码，然后交给cpu执行。

4. 上面的情况，JIT产生了了大胆的想法；它认为哪个while循环执行了十多万次(0.1s)都是执行同样的代码，它直接将stop为false的情况转为机器码缓存起来，等到有人调	用这段代码时，就直接运行缓存起来的机器码；这就才造成了一个线程对共享变量做出修改，其他线程没能读取到最新的值;JIT也留了一手，就是当需要原来的代码时，会将原	  来的代码替换回来。

   

- 验证

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-23_23-34-01.png)

---











代码体现1 【更改jvm参数，-Xint 功能:只用解释器执行的方法执行java代码，不使用JIT进行代码优化】

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VolatitleDemo2 {
    static boolean stop = false;
    static final Logger fgcy = LoggerFactory.getLogger("fgcy");

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            stop = true;
            fgcy.debug("modify stop to true...");
        }).start();
        fool();
    }

    private static void fool() {
        int i = 0;
        while (!stop) {
            i++;
        }
        fgcy.debug("stopping ....." + i);
    }
}
====================================
23:33:28.971 [main] DEBUG fgcy - stopping .....25339669
23:33:28.971 [Thread-0] DEBUG fgcy - modify stop to true...

进程已结束，退出代码为 0
~~~









代码体现二：让循环的次数没那么多，不足以让JIT认为这是一段热点代码

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VolatitleDemo2 {
    static boolean stop = false;
    static final Logger fgcy = LoggerFactory.getLogger("fgcy");

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            try {
                //只等待0.01s 不足以让JIT认为 while代码段是一段热点代码
                Thread.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            }
            stop = true;
            fgcy.debug("modify stop to true...");
        }).start();
        fool();
    }

    private static void fool() {
        int i = 0;
        while (!stop) {
            i++;
        }
        fgcy.debug("stopping ....." + i);
    }
}
===============================================
23:43:13.485 [main] DEBUG fgcy - stopping .....71036
23:43:13.485 [Thread-0] DEBUG fgcy - modify stop to true...

进程已结束，退出代码为 0
~~~







体现三【只有被JIT替换掉的热点代码所在的线程不能获取更新后的值，其他线程可以】(JIT的c1编译器能提升5倍的性能，c2编译器能提升10-100倍的性能)

~~~java
package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VolatitleDemo2 {
    static boolean stop = false;
    static final Logger fgcy = LoggerFactory.getLogger("fgcy");

    public static void main(String[] args) throws Exception {
        new Thread(() -> {
            try {
                //只等待0.01s 不足以让JIT认为 while代码段是一段热点代码
                Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            stop = true;
            fgcy.debug("modify stop to true...");
        }, "t1").start();

        //人为控制t1线程先走
        new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }
            fgcy.debug("STOP IS " + stop);
        }, "t2").start();

        fool();

    }

    private static void fool() {
        int i = 0;
        while (!stop) {
            i++;
        }
        fgcy.debug("stopping ....." + i);
    }
}
============================================
23:54:57.835 [t1] DEBUG fgcy - modify stop to true...
23:54:58.745 [t2] DEBUG fgcy - STOP IS true//循环还没有结束，主线程在一直死循环 
    
~~~







根本解决办法使用关键字volatitle

~~~java
//JIT一旦发现某段代码的某个变量使用volatitle修饰，就不会对这段代码进行优化，即使这段是热点代码
    
  package com.itheima.lock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VolatitleDemo2 {
    static volatile boolean stop = false;
    static final Logger fgcy = LoggerFactory.getLogger("fgcy");

    public static void main(String[] args) throws Exception {
        new Thread(() -> {
            try {
                //只等待0.01s 不足以让JIT认为 while代码段是一段热点代码
                Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            stop = true;
            fgcy.debug("modify stop to true...");
        }, "t1").start();

        //人为控制t1线程先走
        new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }
            fgcy.debug("STOP IS " + stop);
        }, "t2").start();

        fool();

    }

    private static void fool() {
        int i = 0;
        while (!stop) {
            i++;
        }
        fgcy.debug("stopping ....." + i);
    }
}  
=======================================================
00:02:11.462 [main] DEBUG fgcy - stopping .....477446346
00:02:11.462 [t1] DEBUG fgcy - modify stop to true...
00:02:12.353 [t2] DEBUG fgcy - STOP IS true

进程已结束，退出代码为 0
~~~



#### 有序性

- 当不发生指令重排序时，预料的值

~~~java
t1:
 x=1
 y=1
 	t2:
    result.r1=y
    result.r2=x
=================================
"1,1"

t1:
 x=1
   	t2:
    result.r1=y
    result.r2=x  
 y=1
 
=================================
"0,1"
   
t2:
  result.r1=y
  result.r2=x  
        t1:
         	x=1
         	y=1
 
=================================
"0,0"
~~~

- 当发生指令重排序时，可能的结果

~~~java
y=1
    result.r1=y
    result.r=x
x=1
    

   result.r2=x 
x=1
y=1
   result.r1=y
===============================
"1,0"
~~~

- 代码体现

~~~java
package com.itheima.lock;

import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.II_Result;

/**
 * 有序性
 */
public class Reordering {


    @State
    @JCStressTest
    @Outcome(id = {"0,0", "0,1", "1,1"}, expect = Expect.ACCEPTABLE, desc = "ACCEPTABLE")
    @Outcome(id = "1,0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "INTERESTING")
    public static class Case1 {
        int x;
        int y;

        /**
         * 每次执行都会调用有@Actor标注的方法(每轮循环分配一个线程进行测试)
         * 压力测试会尽可能测试足够巨大的次数(以查看所有的可能性)
         */
        @Actor
        public void actor1() {
            x = 1;
            y = 1;
        }

        /**
         * 每次执行都会调用有@Actor标注的方法(每轮循环分配一个线程进行测试)
         * 压力测试会尽可能测试足够巨大的次数(以查看所有的可能性)
         */
        @Actor
        //II_Result是用来接收结果值的
        public void actor2(II_Result result) {
            //r1对应outcome结果的第一位值，r2是第二位值，多组值之间用逗号隔开
            result.r1 = y;
            result.r2 = x;
        }
    }
}
~~~

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-24_17-06-07.png)

---







~~~JAVA
package com.itheima.lock;

import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.II_Result;

/**
 * 有序性
 */
public class Reordering {
    @State
    @JCStressTest
    @Outcome(id = {"0,0", "0,1", "1,1"}, expect = Expect.ACCEPTABLE, desc = "ACCEPTABLE")
    //使用FORBIDDEN，当出现"1,0"的情况会直接报错
    @Outcome(id = "1,0", expect = Expect.FORBIDDEN, desc = "FORBIDDEN")
    public static class Case2 {
        int x;
        //加在这里可以阻止指令重排序
        volatile int y;

        /**
         * 每次执行都会调用有@Actor标注的方法(每轮循环分配一个线程进行测试)
         * 压力测试会尽可能测试足够巨大的次数(以查看所有的可能性)
         */
        @Actor
        public void actor1() {
            x = 1;
            y = 1;
        }

        /**
         * 每次执行都会调用有@Actor标注的方法(每轮循环分配一个线程进行测试)
         * 压力测试会尽可能测试足够巨大的次数(以查看所有的可能性)
         */
        @Actor
        //II_Result是用来接收结果值的
        public void actor2(II_Result result) {
            //r1对应outcome结果的第一位值，r2是第二位值，多组值之间用逗号隔开
            result.r1 = y;
            result.r2 = x;
        }
    }
}
=================================
没有报错，说明指令重排序的问题被解决
~~~

~~~java
package com.itheima.lock;

import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.II_Result;

/**
 * 有序性
 */
public class Reordering {
    @State
    @JCStressTest
    @Outcome(id = {"0,0", "0,1", "1,1"}, expect = Expect.ACCEPTABLE, desc = "ACCEPTABLE")
    //当参数是这个INTERESTING时，表示“1，0”是我感兴趣的结果
    @Outcome(id = "1,0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "INTERESTING")
    public static class Case3 {
        //加在这里不能阻止指令重排序
        volatile int x;
        int y;

        /**
         * 每次执行都会调用有@Actor标注的方法(每轮循环分配一个线程进行测试)
         * 压力测试会尽可能测试足够巨大的次数(以查看所有的可能性)
         */
        @Actor
        public void actor1() {
            x = 1;
            y = 1;
        }

        /**
         * 每次执行都会调用有@Actor标注的方法(每轮循环分配一个线程进行测试)
         * 压力测试会尽可能测试足够巨大的次数(以查看所有的可能性)
         */
        @Actor
        //II_Result是用来接收结果值的
        public void actor2(II_Result result) {
            //r1对应outcome结果的第一位值，r2是第二位值，多组值之间用逗号隔开
            result.r1 = y;
            result.r2 = x;
        }
    }
}

~~~

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-24_17-17-54.png)

---









#### volatitle的原理

---

![image-20220823205117219](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823205117219.png)

---





写操作内存屏障:保证写操作之前的指令不会越过内存屏障，在屏障之前的指令的顺序是不管的
读操作内存屏障:保证读操作之后的指令不能越过内存屏障，在屏障之后的指令的顺序就不管了

## 悲观锁&乐观锁

### 概念

- 悲观锁

悲观锁的代表是synchronized 和 Lock 锁
① 其核心思想是：线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待(进入阻塞队列)；当线程释放锁时，会从阻塞队列中挑一个线程运行
② 线程从运行到阻塞(此时需要记录执行到第几行，涉及哪些变量)、再从阻塞到唤醒(将之前保存的信息进行恢复)，涉及线程上下文切换，如果频繁发生，影响性能
③ 实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作(不会立刻阻塞，会先挣扎两下先)，减少阻塞的机会



- 乐观锁

乐观锁的代表是AtomicInteger【原子整数类】，使用CAS保证原子性
① 其核心思想是无需加锁，每次只有一个线程能成功修改共享变量，【其它失败的线程不需要停止，不断重试直至成功】
② 由于线程一直运行，不需要阻塞，因此不涉及线程上下文又切换
③ 它需要多核cpu支持，且线程数不应超过cpu核数【如果核数不够，又想让线程不停重试，就会发生频繁的上下文切换】



- CAS配合volatile实现并发-

~~~java
import jdk.internal.misc.Unsafe;
// --add-opens java.base/jdk.internal.misc=ALL-UNNAMED
public class SyncVsCas {
    //这个类可以保证修改共享变量是原子操作
    static final Unsafe U = Unsafe.getUnsafe();
    //获得某个类中的某个方法的偏移位置
    static final long BALANCE = U.objectFieldOffset(Account.class, "balance");

    static class Account {
        //Unsafe保证原子性操作，volatile保证可见性
        volatile int balance = 10;
    }
    public static void main(String[] args) {
        Account account = new Account();
        while (true) {
            int o = account.balance;
            int n = o + 5;
            //那o的值与最新的的值进行对比，如果一致就赋予新值
            if (U.compareAndSetInt(account, BALANCE, o, n)) {
                break;
            }
        }
    }
}
~~~

- 小结

synchronized是通过互斥的方式解决线程安全问题；

它将代码块内的多行语句作为一个整体执行(不会发生指令重排现象)，等待的队列进入该锁的阻塞队列；
CAS没有通过互斥解决线程安全，它即使是并行执行发生指令重排序也没有关系，但是它可以通过Unsafe类的比较并修改的方法判断此时想要修改的值有没有被人修改，没有就直接修改，有就循环调用逻辑代码，直到他修改的时候没发现有人在它前面做出修改。





## HashTable & concurrentHashMap

1. Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合,他们的键和值都不能为空。
2. Hashtable 并发度低,整个Hashtable 对应一把锁,同一时刻,只能有一个线程操作它【一把锁，锁住千家万户】。
3. 【1.8 之前】 ConcurrentHashMap 使用了 Segment +数组+链表的结构,每个Segment对应一把锁,如果多个线程访问不同的Segment,则不会冲突；既是segment的数量与并发数有关。
4. 【1.8 开始】 ConcurrentHashMap将【数组的每个头节点】(数组元素个数)作为锁,如果多个线程访问的头节点不同,则不会冲突；数组的容量决定了并发数。
   ① 演示并发 put。
   ② 演示扩容,说明三个问题forwardingNode,扩容时的get,扩容时的put。

HashTable的初始容量不是2的n次幂，而是11，每次扩容都是上一次的容量*2加一，加载因子是0.75；当此时的数组容量是11时，若此时元素个数为9则触发扩容。
因为HashTable的初始容量不是2的n次幂，所以不用进行二次hash，他的容量是质数，所以计算出来的桶下标分布会比较均匀。

### concurrentHashMap

- 初识

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-25_09-28-20.png)

---



- Segment索引计算

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-25_10-18-06.png)

---









- 扩容

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-25_11-08-22.png)

---







- 比较1.7的ConcurrentHashMap

**JDK1.7：**

 	1. segment数组+HashEntry数组+链表
 	2. 在使用构造器创建ConcurrentHashMap对象的时候，就会创建好segment的数组(默认长度为11),包括在segment[0]中创建一个长度为2的HashEntry数组，   可以看成是饿汉式初始化。
 	3. 头插法。
 	4. 当HashEntry数组中的所有元素超过额定值(当前数组长度*加载因子)，扩容为原来的2倍。
 	5. HashEntry数组的初始长度为(capacity/clevel)，当大于二时，取大的值；否则取二。



**JDK1.8：**

1. 数组+链表|红黑树。

2. 在使用构造器创建ConcurrentHashMap对象时，并没有创建底层的数组结构；底层的数组结构是在put第一个元素时创建的可以看成式懒汉式初始化。
3. 尾插法。
4. 当数组中的所有元素达到额定值(当前数组长度*加载因子)，扩容为原来的2倍。
5. 当构造器的capacity参数值为16时，这个参数代表我要在这个数组中放16个元素，此时数组长度*0.75(factor)要大于16，所以此时数组长度为32。
6. 构造器中的有两个参数分别是capacity和factor这两个参数都会在第一次创建数组时才生效，其他的时候factor会默认使用加载因子0.75计算额定值 。



- 并发put

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-25_13-05-50.png)

---





- 扩容

-----

![image-20220823211012412](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823211012412.png)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-25_16-12-13.png)

---



## 谈谈对ThreadLocal的理解

1. ThreadLocal 可以实现【资源对象】的线程隔离,让每个线程各用各的【资源对象】,避免争用引发的线程安全问题(线程间的资源隔离)
2. ThreadLocal 同时实现了线程内的资源共享



- 代码实现

~~~java
package day02;


import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
//线程间的资源隔离
public class TestThreadLocal {
    
    public static void main(String[] args) {
        test1();
    }

    // 多个线程调用, 得到的是自己的 Connection 对象
    private static void test1() {
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                LoggerUtils.get("t").debug("{}", Utils.getConnection());
            }, "t" + (i + 1)).start();
        }
    }

    static class Utils {
        
        private static final ThreadLocal<Object> tl = new ThreadLocal<>();
        
        public static Object getConnection() {
            Object conn = tl.get(); // 到当前线程获取资源
            if (conn == null) {
                conn = innerGetConnection(); // 创建新的对象
                tl.set(conn); // 将资源存入当前线程
            }
            return conn;
        }

        private static Object innerGetConnection() {
            try {
                return new Object();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
================================
[DEBUG] 16:33:03.210 [t3] - java.lang.Object@79e0bff8 
[DEBUG] 16:33:03.210 [t5] - java.lang.Object@8ea112c 
[DEBUG] 16:33:03.210 [t4] - java.lang.Object@24ba6b0b 
[DEBUG] 16:33:03.210 [t2] - java.lang.Object@64ab4b0c 
[DEBUG] 16:33:03.210 [t1] - java.lang.Object@12e3a9c4 
~~~

~~~java
package day02;


import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
//线程间的资源隔离
public class TestThreadLocal {
    public static void main(String[] args) {
        test2();
    }

    // 一个线程内调用, 得到的是同一个 Connection 对象
    private static void test2() {
        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                LoggerUtils.get("t").debug("{}", Utils.getConnection());
                LoggerUtils.get("t").debug("{}", Utils.getConnection());
                LoggerUtils.get("t").debug("{}", Utils.getConnection());
            }, "t" + (i + 1)).start();
        }
    }
    static class Utils {
        private static final ThreadLocal<Object> tl = new ThreadLocal<>();

        public static Object getConnection() {
            Object conn = tl.get(); // 到当前线程获取资源
            if (conn == null) {
                conn = innerGetConnection(); // 创建新的对象
                tl.set(conn); // 将资源存入当前线程
            }
            return conn;
        }

        private static Object innerGetConnection() {
            try {
                return new Object();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
====================================
[DEBUG] 16:35:12.418 [t1] - java.lang.Object@12e3a9c4 
[DEBUG] 16:35:12.418 [t2] - java.lang.Object@2b51a3d2 
[DEBUG] 16:35:12.420 [t1] - java.lang.Object@12e3a9c4 
[DEBUG] 16:35:12.420 [t2] - java.lang.Object@2b51a3d2 
[DEBUG] 16:35:12.420 [t2] - java.lang.Object@2b51a3d2 
[DEBUG] 16:35:12.420 [t1] - java.lang.Object@12e3a9c4
~~~



## ThreadLocal的原理

原理：
    **每个线程内有一个ThreadLocalMap类型的成员变量**,用来存储资源对象

​    调用 set方法,就是以ThreadLocal 自己作为key,资源对象作为value,放入当前线程的ThreadLocalMap集合

​    调用 get 方法,就是以ThreadLocal 自己作为key,到当前线程中查找关联的资源值

​    调用remove 方法,就是以ThreadLocal 自己作为key,移除当前线程关联的资源值



---

![image-20220823203736434](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823203736434.png)

---



### ThreadLocal的释放

为什么ThreadLocalMap 中的key (即ThreadLocal)要设计为弱引用?

      1. Thread 可能需要长时间运行(如线程池中的线程),如果key不再使用,需要在内存不足(GC)时释放其占用的内存
      2. 但GC仅是让key的内存释放,后续还要根据key 是否为null 来进一步释放值的内存,释放时机有a) 获取key 发现 null keyb) set key 时,会使用启发式扫描,清
      3. 除临近的null key,启发次数与元素个数,是否发现nullkey有关remove 时(推荐) ,因为一般使用ThreadLocal 时都把它作为静态变量,因此GC无法回收0



- 调用get方法时，发现null key 

---

![image-20220823203534320](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823203534320.png)

---



- set key时发现null key

-----

![image-20220823203513191](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823203513191.png)

---



- 使用remove

前面两种情况，有一个大前提:就是定义ThreadLocal时不能使用static修饰，否则即使时ThreadLocalMap中的键对是弱引用，但是用static修饰符修饰的变量是一直对ThreadLocal对象保持强引用，所以ThreadLocal对象不会被gc干掉；
这种情况下就需要人为地判断什么时候该释放entry，使用remove方法。
