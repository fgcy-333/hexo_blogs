---
title: 框架篇
date: 2022-08-23 21:49:26
tags:
- 院校帮-面试
categories: 
- 视频学习笔记
---

## ApplicationContext refresh



## refresh 12 个步骤

`1`是做一些准备工作
`2-6`创建和准备beanfactory对象 bean的创建 bean的依赖注入 bean的初始化都是由beanfactory对象完成的
`7-12`为applicationContext特有的功能作准备
`11`是创建的单例bean的创建和初始化

<!--more--> 

### 1.prepareRefresh

---

![image-20220823212602150](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823212602150.png)

---

Environment管理各种键值信息
Environment 的作用之一是为后续 @Value,值注入时提供键值



- 代码体现

~~~java
package day04.refresh;

import org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.beans.factory.config.BeanExpressionContext;
import org.springframework.beans.factory.config.DependencyDescriptor;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.expression.StandardBeanExpressionResolver;
import org.springframework.core.env.Environment;
import org.springframework.core.env.StandardEnvironment;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.support.ResourcePropertySource;

import java.io.IOException;

// 如何获得和解析 @Value 内容
public class TestEnvironment {
    public static void main(String[] args) throws NoSuchFieldException, IOException {
        // 1) 获得 @Value 的值
        System.out.println("仅获取 @Value 值");
        QualifierAnnotationAutowireCandidateResolver resolver = new QualifierAnnotationAutowireCandidateResolver();
        Object name = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField("name"), false));
        System.out.println(name);

        // 2) 解析 @Value 的值
        System.out.println("获取 @Value 值, 并解析${}");
        Object javaHome = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField("javaHome"), false));
        Object jdbcName = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField("jdbcName"), false));
        System.out.println("值:" + javaHome);
        System.out.println("执行解析后${}:" + getEnvironment().resolvePlaceholders(javaHome.toString()));
        System.out.println("执行解析后${}:" + getEnvironment().resolvePlaceholders(String.valueOf(jdbcName)));

        // 3) 解析 SpEL 表达式
        System.out.println("获取 @Value 值, 并解析#{}");
        Object expression = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField("expression"), false));
        //拿到了对应的值
        System.out.println("值:" + expression);
        //将 ${键} 替换成对应的值
        String v1 = getEnvironment().resolvePlaceholders(expression.toString());
        System.out.println("执行解析后${}:" + v1);
        //将 #{} 中的表达式内容进行计算得出结果
        System.out.println("执行解析#{}后:" + new StandardBeanExpressionResolver().evaluate(v1, new BeanExpressionContext(new DefaultListableBeanFactory(), null)));
    }

    private static Environment getEnvironment() throws IOException {
        StandardEnvironment env = new StandardEnvironment();
        env.getPropertySources().addLast(new ResourcePropertySource("jdbc", new ClassPathResource("jdbc.properties")));
        return env;
    }

    static class Bean1 {
        @Value("hello")
        private String name;

        @Value("${JAVA_HOME}")
        private String javaHome;

        @Value("${jdbc.username}")
        private String jdbcName;

        @Value("#{'class version:' + '${java.class.version}'}")
        private String expression;
    }
}
==========================================
仅获取 @Value 值
hello
获取 @Value 值, 并解析${}
值:${JAVA_HOME}
执行解析后${}:D:\sofeware\Idea\JDK1.8
执行解析后${}:root
获取 @Value 值, 并解析#{}
值:#{'class version:' + '${java.class.version}'}
执行解析后${}:#{'class version:' + '61.0'}
执行解析#{}后:class version:61.0
~~~





### 2.obtainFreshBeanFactory

---

![image-20220823212644428](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823212644428.png)

---

BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化
BeanDefinition 作为bean 的设计蓝图,规定了bean的特征,如单例多例、依赖关系、初始销毁方法等
BeanDefinition的来源有多种多样,可以是通过xml获得、通过配置类获得、通过组件扫描获得,也可以是编程添加 



- BeanDefinition来源

~~~java
package day04.refresh;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;
import org.springframework.context.annotation.ConfigurationClassPostProcessor;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;

import java.util.Arrays;

// 演示各种 BeanDefinition 的来源
	public class TestBeanDefinition {
    	public static void main(String[] args) {
            System.out.println("========一开始========");
            //BeanFactory的一个重要的实现类
            DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
            //获取BeanFactory中所有的 BeanDefinition
            System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));

            System.out.println("======== 1从 xml 获取=======");
            //XmlBeanDefinitionReader是专门用来解析xml文件的类，并且构造参器的入参就是BeanFactory实例
            //即 会将从xml文件中解析到的BeanDefinition添加到BeanFactory
            XmlBeanDefinitionReader reader1 = new XmlBeanDefinitionReader(beanFactory);
            reader1.loadBeanDefinitions(new ClassPathResource("bd.xml"));
            System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));

            System.out.println("==========2从配置类获取============");
            //借助spring的工具方法，将Config1类包装成一个名为config1的BeanDefinition对象，再将BeanDefinition对象加入到BeanFactory中
            beanFactory.registerBeanDefinition("config1", BeanDefinitionBuilder.genericBeanDefinition(Config1.class).getBeanDefinition());

            //ConfigurationClassPostProcessor是BeanFactory的后处理器，对BeanFactory进行功能加强
            //即可以解析方法上的注解，将有注解标注的类包装成BeanDefinition添加到BeanFactory中
            //因为配置类是在方法上加@Bean注解，spring的基础功能不能识别并将其包装成BeanDefinition
            //会通过ConfigurationClassPostProcessor进行处理
            ConfigurationClassPostProcessor postProcessor = new ConfigurationClassPostProcessor();
            postProcessor.postProcessBeanDefinitionRegistry(beanFactory);
            System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));
            beanFactory.registerBeanDefinition("config2", BeanDefinitionBuilder.genericBeanDefinition(Config1.class).getBeanDefinition());
            System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));

            System.out.println("===========3扫描获取=============");
            ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(beanFactory);
            scanner.scan("day04.refresh");
            System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));
    }

    static class Bean1 {

    }

    static class Bean2 {

    }

    static class Config1 {
        @Bean
        public Bean2 bean2() {
            return new Bean2();
        }
    }

    static class Config2 {
        @Bean
        public Bean2 bean3() {
            return new Bean2();
        }
    }

    //给组件器别名，不然 TestBeanDefinition.bean44
    @Component("bean44")
    static class Bean44 {

    }
}
===============================================
=======一开始========
[]
======== 1从 xml 获取=======
[bean1]
==========2从配置类获取============
[bean1, config1, bean2]
[bean1, config1, bean2, config2]
===========3扫描获取=============
[bean1, config1, bean2, config2, bean44, bean3, org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory]

~~~



### 3.prepareBeanFactory

----

![image-20220823212740972](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823212740972.png)

---



- 小结

1. StandardBeanExpressionResolver 解析 SpEL
2. ResourceEditorRegistrar 会注释类型转换器,并应用 ApplicationContext 提供的Environment完成${}解析
3. 特殊 bean 指 beanFactory 以及 ApplicationContext【本质上就是对象还不是bean】,通过 registerResolvableDependency 来注册它们
4. ApplicationContextAwareProcessor 用来解析 Aware 接口 ,对bean的各个阶段进行功能加强



### 4.postProcessBeanFactory

1. AbstractApplicationContext类的postProcessBeanFactory方法是空实现，目的是有子类来实现该方法【体现模板方法思想】
2. Application主要有两大类实现，第一种是Web环境下的子类，另一种就是非Web环境下的子类；Web环境下的子类初始化BeanFactory需要更多的信息，比如他需要注册更多的scrope(作用域)sington、prototype、request、session
3. 一般Web 环境的ApplicationContext 都要利用它注册新的Scope,完善 Web 下的BeanFactory
4. 体现的是模板方法设计模式 



### 5.invokeBeanFactoryPostProcessors

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-30_15-34-57.png)

---

1. beanFactory 后处理器,充当beanFactory 的扩展点,可以用来补充或修改BeanDefinition
2. ConfigurationClassPostProcessor - 解析 @Configuration, @Bean, @lmport. @PropertySource 等  
3. 一般的BeanFactory中没有这些方法，如果要使用就需要借助BeanFactory的后处理器，目的是可以添加更多的BeanDefinition到BeanDefinitionMap中



### 6.registerBeanPostProcessors

1. Bean的后处理器，对bean的创建过程中进行的各种功能增强
2. 在BeanDefinitionMap中寻找每一个BeanDefinition看是否有实现PostPorcessors接口，如果有说明这又是一个特殊的bean【bean的后处理器】，将其添加到     BeanProcessors集合中 ，在真正的bean创建时就会使用这些后处理器
3. bean 后处理器,充当bean 的扩展点,可以工作在bean的实例化、依赖注入、初始化阶段
4. AutowiredAnnotationBeanPostProcessor 功能有解析 @Autowired, @Value 注解
5. CommonAnnotationBeanPostProcessor 功能有解析 @Resource, @PostConstruct, @PreDestroy
6. AnnotationAwareAspectjAutoProxyCreator 功能有:为符合切点的目标bean 自动创建代理 
7. registerBeanPostProcessors这一步只是创建了bean后处理器，并将其添加到某一个集合中，实际调用得在后续创建bean时



- 代码体现

~~~java
package day04.refresh;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.annotation.CommonAnnotationBeanPostProcessor;
import org.springframework.context.support.GenericApplicationContext;

import javax.annotation.Resource;

/**
 * 一些重要的Bean后处理器
 */
public class TestBeanPostProcessor {

    public static void main(String[] args) {
        //ApplicationContext的一个简单实现【标准的beanFactory缺失一些功能】需要扩展功能
        //加入多个bean(bean的后处理器)
        GenericApplicationContext context = new GenericApplicationContext();
        //通过applicationContext拿到它内部的一个BeanFactory
        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();
        //通过编程的方式注入了一些Bean
        //即创建一些固定名称的BeanDefinition对象添加到beanFactory中
        beanFactory.registerBeanDefinition("bean1", BeanDefinitionBuilder.genericBeanDefinition(Bean1.class).getBeanDefinition());
        beanFactory.registerBeanDefinition("bean2", BeanDefinitionBuilder.genericBeanDefinition(Bean2.class).getBeanDefinition());
        beanFactory.registerBeanDefinition("bean3", BeanDefinitionBuilder.genericBeanDefinition(Bean3.class).getBeanDefinition());
        beanFactory.registerBeanDefinition("aspect1", BeanDefinitionBuilder.genericBeanDefinition(Aspect1.class).getBeanDefinition());
        //当需要创建bean时，就会有人去扫描beanFactory，扫描出bean的后处理器
        //AutowiredAnnotationBeanPostProcessor用于解析@Autowired\@Value
        beanFactory.registerBeanDefinition("processor1",
                BeanDefinitionBuilder.genericBeanDefinition(AutowiredAnnotationBeanPostProcessor.class).getBeanDefinition());

        //CommonAnnotationBeanPostProcessor解析 @Resource, @PostConstruct, @PreDestroy注解
        beanFactory.registerBeanDefinition("processor2",
                BeanDefinitionBuilder.genericBeanDefinition(CommonAnnotationBeanPostProcessor.class).getBeanDefinition());
        //AnnotationAwareAspectJAutoProxyCreator解析@Aspect注解和@Before注解
        //当发现有某个方法契合切面类定义的el表达式时，就不会创建普通的bean，而是会创建代理对象
        //在代理对象中进行功能增强，先调用前置通知，然后调用真正的目标方法
        beanFactory.registerBeanDefinition("processor3",
                BeanDefinitionBuilder.genericBeanDefinition(AnnotationAwareAspectJAutoProxyCreator.class).getBeanDefinition());
        //通过调用context的refresh方法配置好容器
        context.refresh();
        //拿到BeanFactory对象从中拿一个指定类型的bean
        //然后调用其foo方法
        beanFactory.getBean(Bean1.class).foo();
    }

    static class Bean1 {
        Bean2 bean2;
        Bean3 bean3;

        @Autowired
        public void setBean2(Bean2 bean2) {
            System.out.println("发生了依赖注入..." + bean2);
            this.bean2 = bean2;
        }

        @Resource
        public void setBean3(Bean3 bean3) {
            System.out.println("发生了依赖注入..." + bean3);
            this.bean3 = bean3;
        }

        public void foo() {
            System.out.println("foo");
        }
    }

    static class Bean2 {

    }

    static class Bean3 {

    }

    //一个切面类
    @Aspect
    static class Aspect1 {
        //给符合expression表达式的方法添加一个前置通知
        @Before("execution(* foo())")
        public void before() {
            System.out.println("before...");
        }
    }
}
====================================================
发生了依赖注入...day04.refresh.TestBeanPostProcessor$Bean3@19b843ba
发生了依赖注入...day04.refresh.TestBeanPostProcessor$Bean2@dc9876b
before...
foo
~~~



### 7.initMessageSource

1. ApplicatonContext的一个多有功能，beanFactroy中没有
2. 实现国际化
3. 容器【beanDefinition】中一个名为messageSource 的bean,如果没有,则提供空的MessageSource 实现



### 8.initApplicationEventMulticaster

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-31_09-55-51.png)

---

1. 用来发布事件给监听器
2. 可以从容器【beanDefinitionMap】中找名为 applicationEventMulticaster 的bean作为事件广播器,若没有,也会新建默认的事件广播器
3. 可以调用 ApplicationContext.publishEvent(事件对象)来发布事件
4. applicationEventMulticaster中有一个集合，存放所有的监听器，当applicationEventMulticaster发布事件时，会遍历集合找到对该事件感兴趣的监听器



### 9.onRefresh

1. 这一步是空实现，留给子类扩展
2. SpringBoot 中的子类可以在这里准备WebServer,即内嵌web容器，SpringBoot中有内嵌的web容器
3. 体现的是模板方法设计模式 



### 10.registerListeners

1. 用来接收事件
2. 一部分监听器是事先编程添加的、另一部分监听器来自容器中的bean、还有一部分来自于@EventListener的方法的解析
3. 实现ApplicationListener接口,重写其中 onApplicationEvent(E e)方法即可 ，然后会将该监听器添加到applicationEvenMulticaster的集合中



### 11.finishBeanFactorylnitialization

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-31_10-16-44.png)

----

1. conversionService也是一套转换机制,作为对PropertyEditor 的补充
2. embeddedValueResolvers(内嵌值解析器)用来解析 @Value 中的${},借用的是Environment 的功能
3. singletonObjects(单例池)【一个Map集合】用来缓存所有非延迟单例对象,对象的创建都分三个阶段【bean的创建、依赖注入和初始化】,每一阶段都有不同的bean后处理器参与进来,扩展功能



### 12.finishRefresh

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-31_10-26-16.png)

---

1. lifecycleProcessor【生命周期处理器】用来控制容器内需要生命周期管理的bean
2. 如果容器【beanDefinitionMap】中有名称为lifecycleProcessor的bean 就用它,否则创建默认的生命周期管理器
3. 调用 context的start,即可触发所有实现LifeCycle接口 bean 的start 
4. 调用context 的 stop,即可触发所有实现LifeCycle接口bean的stop
5. 最后会发布ContextRefreshed事件，表示整个refresh阶段完成【整个Spring容器已经初始化完成】



## refresh的总结

1. prepareRefresh - 创建一个Environment对象，为spring后续的功能做好准备一些键值信息
2. obtainFreshBeanFactory - 创建或获取 BeanFactory

3. prepareBeanFactory - 准备 BeanFactory【为beanFactory准备好成员变量；如:EL表达式的解析器，类型转换器】
4. postProcessBeanFactory - 子类拓展 BeanFactory
5. invokeBeanFactoryPostProcessors - BeanFactory后处理器，可以解析配置类的相关注解如@Configuration、@Bean，@Import
6. registerBeanPostProcessors - 准备 Bean 后处理器，在后续bean的创建、依赖注入、初始化时使用@Autowired，@Value、@PostConstruct, @PreDestroy、@Aspect
7. initMessageSource - 为 ApplicationContext 提供国际化功能
8. initApplicationEventMulticaster - 为 ApplicationContext 提供事件发布器，里面有一个集合，用于维护所有实现了applicationListener的bean
9. onRefresh - 留给子类扩展
10. registerListeners - ApplicationContext 准备监听器
11. finishBeanFactorylnitialization - 初始化非延迟单例Bean,在创建每一个bean时，执行Bean 后处理器扩展
12. finishRefresh - 准备生命周期管理器,由事件发布器发布 ContextRefreshed 事件 



## Spring Bean的生命周期

从创建到销毁，spring主要做了什么事情

~~~java
//入口
//spring中的bean都符合懒惰式加载的，即一开始spring并不会创建这些bean，只有当第一次想要获取这个bean时，才会创建bean，然后依赖注入，然后初始化
 protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException 
~~~



### 阶段1:处理名称,检查缓存

1. 别名处理，一个bean可以有多个别名，先把别名解析为实际名称,再使用真实的名称进行后续处理
2. FactoryBean，用于生产对象的工厂bean，若要FactoryBean 本身,需要使用&名称获取，如果不加&会取工厂中的产品
3. singletonObjects 是一级缓存,放单例成品对象【当想要获取bean时，先看缓存有没有这个bean如果没有，看一下父有没有容器，再找父容器，父容器没有才考虑创建】
4. singletonFactories 是三级缓存,放单例工厂【用于解决循环依赖】
5. earlySingletonObjects 是二级缓存,放单例工厂的产品,可称为提前单例对象 【解决既有代理，又有循环有依赖】



### 阶段2:检查父工厂

1. 当想要获取bean时，先看缓存有没有这个bean如果没有，看一下父有没有容器，再找父容器，父容器没有才考虑创建
2. 父子容器的bean名称可以重复
3. 优先找子容器的bean,找到了直接返回,找不到继续到父容器找    



### 阶段3:检查DependsOn

有dependsOn时的bean初始化顺序：dependsOn用在非显示依赖的bean的创建顺序控制，A dependsOn B B先创建



### 阶段4:按Scope创建bean

常见的作用域:singleton、prototype、request、session、application





- 代码体现

~~~java
package day04.bean;

import day02.LoggerUtils;
import org.springframework.context.annotation.CommonAnnotationBeanPostProcessor;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.RequestScope;
import org.springframework.web.context.request.ServletWebRequest;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

public class TestScope {
    public static void main(String[] args) {
        //testSingletonScope();//容器结束前
        //testPrototypeScope();//自己调用
        testRequestScope();//请求结束前
    }

    // 单例 bean 从 refresh 被创建, 到 close 被销毁, BeanFactory 会记录哪些 bean 要调用销毁方法
    private static void testSingletonScope() {
        //创建一个最简单spring容器
        GenericApplicationContext context = new GenericApplicationContext();
        //注册一个名为BeanDefinition的对象添加到beanDefinitionMap中
        context.registerBean("bean1", Bean1.class);
        //注册一个bean的后处理器，用于解析@Resource @PostConstruct @PreDestroy
        context.registerBean(CommonAnnotationBeanPostProcessor.class);
        //
        // 【单例bean】准备好spring容器 就相当于调用容器的getBean方法，创建或获取每一个单例bean，维护在单例池中
        context.refresh();
        //【单例bean】当容器调用close方法时，此时会遍历容器中的bean看是否有销毁方法，有就会调用
        context.close();
    }

    // 多例 bean 从首次 getBean 被创建, 到调用 BeanFactory 的 destroyBean 被销毁
    private static void testPrototypeScope() {
        GenericApplicationContext context = new GenericApplicationContext();
        //默认的作用域时singletonScope，当需要使用其他作用域时，需要在蓝图中进行指定
        context.registerBean("bean1", Bean1.class, bd -> bd.setScope("prototype"));
        //注册一个bean的后处理器，用于解析@Resource @PostConstruct @PreDestroy
        context.registerBean(CommonAnnotationBeanPostProcessor.class);
        //准备好spring容器0【多例模式下是不会提前创建每一个bean维护在单例池中，想要用的时候自己getBean】
        context.refresh();
        //获取指定类型的bean
        Bean1 bean = context.getBean(Bean1.class);
        // 没谁记录该 bean 要调用销毁方法, 需要我们自行调用
        context.getDefaultListableBeanFactory().destroyBean(bean);

        context.close();
    }

    // request bean 从首次 getBean 被创建, 到 request 结束前被销毁
    private static void testRequestScope() {
        //定义一个简单的容器实现
        GenericApplicationContext context = new GenericApplicationContext();
        //在非web的环境下需要自己添加RequestScope的bean
        context.getDefaultListableBeanFactory().registerScope("request", new RequestScope());
        //默认的作用域时singletonScope，当需要使用其他作用域时，需要在蓝图中进行指定
        context.registerBean("bean1", Bean1.class, bd -> bd.setScope("request"));
        //bean后处理器
        context.registerBean(CommonAnnotationBeanPostProcessor.class);
        //主备好容器
        context.refresh();

        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                //spring提供的假的request对象，用于测试
                MockHttpServletRequest request = new MockHttpServletRequest();
                //将request对象进行封装
                // 每个 webRequest 对象会记录哪些 bean 要调用销毁方法
                ServletWebRequest webRequest = new ServletWebRequest(request);
                //将ServletWebRequest绑定到当前线程
                RequestContextHolder.setRequestAttributes(webRequest);
                //当bean创建出来后就会存放在request中
                Bean1 bean = context.getBean(Bean1.class);
                //在同一个request中是同一个bean
                LoggerUtils.get().debug("{}", bean);
                LoggerUtils.get().debug("{}", request.getAttribute("bean1"));

                //请求结束前调用 request域中保存的bean的销毁方法
                webRequest.requestCompleted();
            }).start();
        }

    }

    static class Bean1 {
        //初始化方法
        @PostConstruct
        public void init() {
            LoggerUtils.get().debug("{} - init", this);
        }

        //销毁方法
        @PreDestroy
        public void destroy() {
            LoggerUtils.get().debug("{} - destroy", this);
        }
    }
}
=======================testSingletonScope==========================
[DEBUG] 15:53:31.373 [main] - day04.bean.TestScope$Bean1@1fa121e2 - init 
[DEBUG] 15:53:31.395 [main] - day04.bean.TestScope$Bean1@1fa121e2 - destroy 

=======================testPrototypeScope==========================
[DEBUG] 15:54:13.690 [main] - day04.bean.TestScope$Bean1@37883b97 - init 
[DEBUG] 15:54:13.693 [main] - day04.bean.TestScope$Bean1@37883b97 - destroy    
        
=======================testRequestScope==========================
[DEBUG] 15:54:43.628 [Thread-0] - day04.bean.TestScope$Bean1@14b6092f - init 
[DEBUG] 15:54:43.628 [Thread-1] - day04.bean.TestScope$Bean1@69316170 - init 
[DEBUG] 15:54:43.631 [Thread-0] - day04.bean.TestScope$Bean1@14b6092f 
[DEBUG] 15:54:43.631 [Thread-1] - day04.bean.TestScope$Bean1@69316170 
[DEBUG] 15:54:43.631 [Thread-0] - day04.bean.TestScope$Bean1@14b6092f 
[DEBUG] 15:54:43.631 [Thread-1] - day04.bean.TestScope$Bean1@69316170 
[DEBUG] 15:54:43.631 [Thread-1] - day04.bean.TestScope$Bean1@69316170 - destroy 
[DEBUG] 15:54:43.631 [Thread-0] - day04.bean.TestScope$Bean1@14b6092f - destroy 
~~~

- 小结

1. scope 理解为从xxx范围内找这个bean更加贴切
2. singleton scope 表示从单例池范围内获取bean,如果没有,则创建并放入单例池
3. prototype scope 表示从不缓存 bean,每次都创建新的
4. request scope 表示从 request 对象范围内获取 bean,如果没有,则创建并放入request...



### 阶段5:创建bean

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-31_16-15-00.png)

---



- 创建阶段---主要掌握两种

AutowiredAnnotationBeanPostPrecessor选择构造:优先选择带有@Autowired注解的构造器初始化bean；如有唯一的 带参数的构造器，也会使用该构造

采用默认构造:【保底策略】如果AutowiredAnnotationBeanPostPrecessor后处理器和BeanDefinition都没有找到构造，采用默认的无参构造，即使是私有的【暴力反射】



- 依赖注入阶段

1. AutowiredAnnotationBeanPostProcessor(注解匹配)：识别 @Autowired 及 @Value 标注的成员,将这些成员封装为InjectionMetadata ，然后由InjectionMetadata 进行依赖注入
2. CommonAnnotationBeanPostProcessor(注解匹配)：识别@Resource 标注的成员,封装为InjectionMetadata ，然后由InjectionMetadata 进行依赖注入
3. AUTOWIRE_BY_NAME(根据名字匹配):定义bean的时候可以添加这个配置，根据成员名字到容器中寻找有么有该名字的bean 对象,有就完成接下来的依赖注入；修改 mbd 的 propertyValues,不会考虑简单类型的成员
4. AUTOWIRE_BY_TYPE(根据类型匹配)：定义bean的时候可以添加这个配置，根据成员类型到容器中寻找有么有该类型的bean ，有就完成接下来的依赖注入resolveDependency找到依赖注入的值,修改mbd 的 propertyValues 
   5.applyPropertyValues(xml中 <property name reflvalue(精确指定)/>)：在xml文件中指定某个bean需要某个值，根据 mbd propertyValues 进行依赖注入



- 代码体现

~~~java
package day04.bean;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.support.GenericApplicationContext;

// 测试如果对同一属性进行的 @Autowired 注入、AUTOWIRE_BY_NAME、精确指定注入名称, 优先级是怎样的
public class TestInjection {
    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
        //将bean1的蓝图添加到beanDefinitionMap中，并在蓝图中指定依赖注入的方式
        context.registerBean("bean1", Bean1.class, bd -> {
            // 优先级最高的：精确指定注入 bean 的名称 <property name="bean3" ref="bean2"/>【精准匹配 1】
            bd.getPropertyValues().add("bean3", new RuntimeBeanReference("bean2"));
            // 优先级次之的：通过 AUTOWIRE_BY_NAME 匹配【名字匹配 2】
            ((RootBeanDefinition) bd).setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_NAME);
        });
        context.registerBean("bean2", Bean2.class);
        context.registerBean("bean3", Bean3.class);
        context.registerBean("bean4", Bean4.class);

        context.refresh();
    }

    static class Bean1 {
        MyInterface bean;

        // 优先级最低的：@Autowired 匹配【注解匹配 3】
        @Autowired//给MyInterface bean进行依赖注入
        @Qualifier("bean4")//类型相同时【bean2、bean3、bean4类型都是MyInterface】，需要指定名字匹配
        //根据名字匹配是根据setter的名字进行匹配 此处是bean3
        public void setBean3(MyInterface bean) {
            System.out.println(bean);
            this.bean = bean;
        }
    }

    interface MyInterface {
    }

    static class Bean2 implements MyInterface {
    }

    static class Bean3 implements MyInterface {
    }

    static class Bean4 implements MyInterface {
    }
}
========================================
day04.bean.TestInjection$Bean2@434a63ab
    
~~~



- 初始化阶段

1. 内置Aware接口的装配 包括BeanNameAware接口, BeanFactoryAware接口等 只要bean实现了Aware接口 那么在bean的初始化阶段 beanFactory就会回调这些方法
2. 扩展Aware接口的装配
3. @PostConstruct 标注这是这个bean的初始化方法，该注解是通过一个bean后处理器(CommonAnnotationBeanPostProcessor)进行识别和调用，执行时机在postProcessBeforeInitialization
4. 实现由spring提供的initializingBean接口，在bean初始化阶段时通过接口回调实现初始化
5. 在beanDefinition中规定哪个方法是初始化方法，有两种方式指定：一、在xml中<bean init-method> 二、@Bean(initMethod)
6. 通过AnnotationAwareAspectJAutoProxyCreator 一个bean后处理器识别@Aspect注解，创建aop代理，执行时机在postProcessAfterInitialization【在初始化的最后一步创建aop代理】





- 代码体现

~~~java
package day04.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.annotation.CommonAnnotationBeanPostProcessor;
import org.springframework.context.support.GenericApplicationContext;

import javax.annotation.PostConstruct;

public class TestInitialization {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(CommonAnnotationBeanPostProcessor.class);
        // <bean init-method="initMethod">
        context.registerBean("bean1", Bean1.class, bd -> bd.setInitMethodName("initMethod"));
        context.refresh();
    }

    static class Bean1 implements InitializingBean, BeanFactoryAware {

        //实现spring提供的InitializingBean接口进行初始化【第三】
        @Override
        public void afterPropertiesSet() throws Exception {
            System.out.println(1);
        }

        //使用CommonAnnotationBeanPostProcessor解析@postConstruce经行初始化【第二】
        @PostConstruct
        public void init() {
            System.out.println(2);
        }

        //通过在蓝图中指定初始化方法最后【第四】
        public void initMethod() {
            System.out.println(3);
        }

        //实现Aware接口的方法进行初始化优先级最高
        @Override
        public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
            System.out.println(4);
        }
    }
}
=================================
4
2
1
3
~~~





- 注册可销毁bean

判断依据

      1. 如果实现了DisposableBean【与InitializingBean接口对应，一个是实现初始化接口、一个是销毁接口】 或 AutoCloseable 接口,则为可销毁bean
      2. 如果自定义了destroyMethod,则为可销毁bean. @Bean(destroyMethod='xxx')
      3. 如果采用 @Bean 没有指定destroyMethod,则采用自动推断方式获取销毁方法名(close, shutdown).
      4. 如果有@PreDestroy 标注的方法CommonAnnotationBeanPostProcessor bean后处理器
         存储位置
      5. singleton scope的可销bean 会存储于beanFactory的成员当中【这个成员变量是一个集合】【当beanFactory调用close方法时，会遍历集合中的bean，调用其销毁方法】
      6. 自定义scope的可销毁bean会存储于对应的域对象当中 例如request、session；当与对象的生命周期结束时，会找到域中的bean并调用其销毁方法
      7. prototype scope 不会存储,需要自己找到此对象销毁
      8. 存储时都会封装为DisposableBeanAdapter类型对销毁方法的调用进行适配【体现适配器模式】



- 阶段6 类型转化

​		如果 getBean 的requiredType 参数与实际得到的对象类型不同,会尝试进行类型转换

~~~java
if (requiredType != null && !requiredType.isInstance(bean)) {
            try {
                Object convertedBean = this.getTypeConverter().convertIfNecessary(bean, requiredType);
                if (convertedBean == null) {
                    throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                } else {
                    return convertedBean;
                }
            } catch (TypeMismatchException var5) {
                if (this.logger.isTraceEnabled()) {
                    this.logger.trace("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", var5);
                }

                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
        } else {
            return bean;
        }
~~~



- 阶段7：销毁bean

1. singleton bean 的销毁在 ApplicationContext.close 时,此时会找到所有实现DisposableBean接口的bean,逐一销毁
2. 自定义 scope bean 的销毁在作用域对象生命周期结束时
3. prototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁将bean作为方法参数传入
4. 同一bean 中不同形式销毁方法的调用次序.
       优先后处理器销毁,即@PreDestroy.
       其次DisposableBean 接口销毁.
       最后destroyMethod 销毁(包括自定义名称,推断名称,AutoCloseable接口 多选一)



### 总结

阶段1:处理名称,检查缓存 将别名换成真实名称，取缓存中找bean
阶段2:检查父工厂 自己没有这个bean 看父工厂有没有 没有才创建
阶段3:检查DependsOn 先创建所依赖的bean 或是创建指定先创建的bean
阶段4:按Scope创建bean 将其存放在不同的位置中 注意 prototype不会特地使用某个集合进行管理，需要自己管理
    ① 创建singleton
    ② 创建 prototype
    ③ 创建其它scope request、session、application
阶段5:创建bean
    1.创建bean实例-@Autowired、唯一带参构造、默认无参构造
    2.依赖注入- @Autowired @Value, @Resource, ByName ByType, 精确指定
    3.初始化 - Aware 接口处理, @PostConstruct, InitializingBean, initMethod 创建代理对象
    4.登记可销毁bean DisposableBean接口和AutoCloseable接口 #Bean(destroyMethod='xxx') @Predestroy、
阶段6:类型转换
阶段7:销毁bean



## Spring事务失效几种场景和解决方法

### 1. 抛出检查异常导致事务不能正确回滚

原因: Spring默认只会回滚非检查异常
解法: 配置rollbackFor属性



- account.sql

~~~sql
drop table if exists account;
create table account
(
    accountNo int primary key auto_increment,
    balance   int not null
)ENGINE=InnoDB DEFAULT CHARSET=utf8;#记住数据库引擎式InnoDB【不然不会启动事务】

insert into account (accountNo, balance)
values (1, 1000),
       (2, 1000);
~~~



- jdbc.properties

~~~properties
jdbc.driverClassName=com.mysql.cj.jdbc.Driver
jdbc.jdbcUrl=jdbc:mysql://localhost:3306/test?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
jdbc.username=test
jdbc.password=test123
~~~



- AppConfigure

~~~java
package day04.tx;

import com.zaxxer.hikari.HikariDataSource;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.*;
import org.springframework.core.io.ClassPathResource;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.jdbc.datasource.init.DataSourceInitializer;
import org.springframework.jdbc.datasource.init.DatabasePopulator;
import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.AnnotationTransactionAttributeSource;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.interceptor.TransactionAttributeSource;

import javax.sql.DataSource;

@Configuration//配置类
@PropertySource("classpath:jdbc.properties")//读取配置文件
@EnableTransactionManagement//申明式的事务管理
@EnableAspectJAutoProxy(exposeProxy = true)//开启了AOP
@ComponentScan("day04.tx.app.service")//spring包扫描
@MapperScan("day04.tx.app.mapper")//mybatis的包扫描
public class AppConfig {

    /*
     * 配置数据源
     * */
    @ConfigurationProperties("jdbc")
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }

    /*
     * 数据源的初始化器
     * */
    @Bean
    public DataSourceInitializer dataSourceInitializer(DataSource dataSource, DatabasePopulator populator) {
        DataSourceInitializer dataSourceInitializer = new DataSourceInitializer();
        dataSourceInitializer.setDataSource(dataSource);
        dataSourceInitializer.setDatabasePopulator(populator);
        return dataSourceInitializer;
    }

    /*
     * 每次初始化就会执行sql脚本 DDL 保证数据一致
     * */
    @Bean
    public DatabasePopulator databasePopulator() {
        return new ResourceDatabasePopulator(new ClassPathResource("account.sql"));
    }

    /*
     * 因为要使用到mybatis 所以要有sqlSessionFactory
     * */
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        return factoryBean;
    }

    /*
     * 配合Mybatis一起使用的事务管理器【申明式事务】
     * */
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean
    // 只要 beanFactory 的 allowBeanDefinitionOverriding==true, 即使系统的 @Bean 定义没有 @ConditionalOnMissingBean 条件，也会被我们的同名 @Bean 覆盖掉
    //@Transaction注解默认只能对public的方法生效【非public方法加上也不会报错，但就是不会开启事务】，此处将入参设置为false，此时在其他修饰符的方法上加@Transaction注解，依然可以开启事务【不推荐】
    public TransactionAttributeSource transactionAttributeSource() {
        return new AnnotationTransactionAttributeSource(false);
    }

}

~~~



- AccountMapper

~~~java
package day04.tx.app.mapper;

import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.Update;

public interface AccountMapper {

    @Update("update account set balance=balance+#{balance} where accountNo=#{accountNo}")
    void update(@Param("accountNo") int accountNo, @Param("balance") int balance);

    @Select("select balance from account where accountNo=#{accountNo} for update")
    int findBalanceBy(int accountNo);
}

~~~



- AccountService

~~~java
package day04.tx.app.service;

import day04.tx.app.mapper.AccountMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

@Service
public class Service1 {

    @Autowired
    private AccountMapper accountMapper;

    //spring默认只会 对 RuntimeException 或 Error 经行回滚操作
    @Transactional(rollbackFor = Exception.class)
    public void transfer(int from, int to, int amount) throws FileNotFoundException {
        int fromBalance = accountMapper.findBalanceBy(from);
        if (fromBalance - amount >= 0) {
            accountMapper.update(from, -1 * amount);
            new FileInputStream("aaa");
            accountMapper.update(to, amount);
        }
    }
}
~~~



- TestAccountService

~~~java
package day04.tx.app.service;

import day04.tx.AppConfig;
import org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.support.GenericApplicationContext;

import java.io.FileNotFoundException;

public class TestService1 {
    public static void main(String[] args) throws FileNotFoundException {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());
        context.registerBean(AppConfig.class);
        context.refresh();

        Service1 bean = context.getBean(Service1.class);
        bean.transfer(1, 2, 500);
    }
}
==========================================
[INFO] 10:26:55.248 [main] - HikariPool-1 - Starting... 
[INFO] 10:26:55.365 [main] - HikariPool-1 - Start completed. 
[DEBUG] 10:26:55.468 [main] - Creating new transaction with name [day04.tx.app.service.Service1.transfer]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 10:26:55.468 [main] - Acquired Connection [HikariProxyConnection@405950359 wrapping com.mysql.cj.jdbc.ConnectionImpl@64f555e7] for JDBC transaction 
[DEBUG] 10:26:55.469 [main] - Switching JDBC Connection [HikariProxyConnection@405950359 wrapping com.mysql.cj.jdbc.ConnectionImpl@64f555e7] to manual commit 
[DEBUG] 10:26:55.482 [main] - ==>  Preparing: select balance from account where accountNo=? for update  
[DEBUG] 10:26:55.499 [main] - ==> Parameters: 1(Integer) 
[DEBUG] 10:26:55.521 [main] - <==      Total: 1 
[DEBUG] 10:26:55.526 [main] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 10:26:55.526 [main] - ==> Parameters: -500(Integer), 1(Integer) 
[DEBUG] 10:26:55.528 [main] - <==    Updates: 1 
[DEBUG] 10:26:55.528 [main] - Initiating transaction rollback 
[DEBUG] 10:26:55.528 [main] - Rolling back JDBC transaction on Connection [HikariProxyConnection@405950359 wrapping com.mysql.cj.jdbc.ConnectionImpl@64f555e7] 
[DEBUG] 10:26:55.537 [main] - Releasing JDBC Connection [HikariProxyConnection@405950359 wrapping com.mysql.cj.jdbc.ConnectionImpl@64f555e7] after transaction 
Exception in thread "main" java.io.FileNotFoundException: aaa (系统找不到指定的文件。) 
~~~





### 2. 业务方法内自己try catch异常导致事务不能正确回滚

原因:
当在配置类中定义了申明式事务，从容器中获取bean时，得到的不是原来的业务对象，而是一个代理对象，通过代理对象内部会添加事务控制，在事务通知内部才会调用原始的业务方法；事务通知只有捉到了目标抛出的异常,才能进行后续的回滚处理,如果目标自己处理掉异常,事务通知无法知悉，它就不会调用回滚
解法
    1:异常原样抛出解法
    2:手动设置TransactionStatus.setRollbackOnly()





- AccountService

~~~java
package day04.tx.app.service;

import day04.tx.app.mapper.AccountMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.interceptor.TransactionInterceptor;

import java.io.FileInputStream;
import java.io.FileNotFoundException;

@Service
public class Service2 {

    @Autowired
    private AccountMapper accountMapper;

    @Transactional(rollbackFor = Exception.class)
    public void transfer(int from, int to, int amount) {
        try {
            int fromBalance = accountMapper.findBalanceBy(from);
            if (fromBalance - amount >= 0) {
                accountMapper.update(from, -1 * amount);
                new FileInputStream("aaa");
                accountMapper.update(to, amount);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //抛的如果不是运行时异常，就需要在方法上throws 异常给调用者
            //throw new RuntimeException(e);
            //告诉外层调用者，此时应该回滚了
            TransactionInterceptor.currentTransactionStatus().setRollbackOnly();
        }
    }
}
=========================================
[INFO] 11:17:01.466 [main] - HikariPool-1 - Starting... 
[INFO] 11:17:01.580 [main] - HikariPool-1 - Start completed. 
[DEBUG] 11:17:01.681 [main] - Creating new transaction with name [day04.tx.app.service.Service2.transfer]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 11:17:01.681 [main] - Acquired Connection [HikariProxyConnection@405950359 wrapping com.mysql.cj.jdbc.ConnectionImpl@64f555e7] for JDBC transaction 
[DEBUG] 11:17:01.682 [main] - Switching JDBC Connection [HikariProxyConnection@405950359 wrapping com.mysql.cj.jdbc.ConnectionImpl@64f555e7] to manual commit 
[DEBUG] 11:17:01.697 [main] - ==>  Preparing: select balance from account where accountNo=? for update  
[DEBUG] 11:17:01.713 [main] - ==> Parameters: 1(Integer) 
[DEBUG] 11:17:01.731 [main] - <==      Total: 1 
[DEBUG] 11:17:01.735 [main] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 11:17:01.735 [main] - ==> Parameters: -500(Integer), 1(Integer) 
[DEBUG] 11:17:01.736 [main] - <==    Updates: 1 
[DEBUG] 11:17:01.737 [main] - Initiating transaction rollback 
[DEBUG] 11:17:01.738 [main] - Rolling back JDBC transaction on Connection [HikariProxyConnection@405950359 wrapping com.mysql.cj.jdbc.ConnectionImpl@64f555e7] 
java.io.FileNotFoundException: aaa (系统找不到指定的文件。)
~~~



### 3.aop切面顺序导致导致事务不能正确回滚

原因:事务切面优先级最低,但如果自定义的切面优先级和他一样,则还是自定义切面在内层,这时若自定义切面没有正确抛出异常，异常被内部消化了，事务通知认为是正确的情况，不会处理【回滚】
解法:
    让切面外抛异常【推荐】
    让切面修改事务状态
    修改切面和事务通知的优先级@Order(数值越大，优先级越小)





- TestAccountService

~~~java
package day04.tx.app.service;

import day02.LoggerUtils;
import day04.tx.AppConfig;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.transaction.interceptor.TransactionInterceptor;

import java.io.FileNotFoundException;

public class TestService3 {
    public static void main(String[] args) throws FileNotFoundException {
        //applicationContext的简单实现
        GenericApplicationContext context = new GenericApplicationContext();
        //提供一些必要的bean处理器和beanFactory处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());
        //将切面类和配置类添加到beanDefinition容器中
        context.registerBean(MyAspect.class);
        context.registerBean(AppConfig.class);
        context.refresh();

        Service3 bean = context.getBean(Service3.class);
        bean.transfer(1, 2, 500);
    }

    @Aspect
    @Order(Ordered.LOWEST_PRECEDENCE - 1)
    static class MyAspect {

        //环绕增强（transfer方法）
        @Around("execution(* transfer(..))")
        public Object around(ProceedingJoinPoint pjp) throws Throwable {
            LoggerUtils.get().debug("log:{}", pjp.getTarget());
            try {
                //有下一个通知就调用下一个通知
                //没有下一个通知就调用目标方法
                return pjp.proceed();
            } catch (Throwable e) {
                //向事务通知抛异常
                //throw new RuntimeException();
                //调用事务拦截器，获取当前事务状态，设置为回滚
                TransactionInterceptor.currentTransactionStatus().setRollbackOnly();
            }
        }
    }
}
=============================================================
[INFO] 13:49:29.769 [main] - HikariPool-1 - Starting... 
[INFO] 13:49:29.890 [main] - HikariPool-1 - Start completed. 
[DEBUG] 13:49:30.027 [main] - log:day04.tx.app.service.Service3@3104f7bd //改变优先级
[DEBUG] 13:49:30.028 [main] - Creating new transaction with name [day04.tx.app.service.Service3.transfer]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 13:49:30.028 [main] - Acquired Connection [HikariProxyConnection@1498705150 wrapping com.mysql.cj.jdbc.ConnectionImpl@29ea78b1] for JDBC transaction 
[DEBUG] 13:49:30.029 [main] - Switching JDBC Connection [HikariProxyConnection@1498705150 wrapping com.mysql.cj.jdbc.ConnectionImpl@29ea78b1] to manual commit 
[DEBUG] 13:49:30.043 [main] - ==>  Preparing: select balance from account where accountNo=? for update  
[DEBUG] 13:49:30.058 [main] - ==> Parameters: 1(Integer) 
[DEBUG] 13:49:30.078 [main] - <==      Total: 1 
[DEBUG] 13:49:30.082 [main] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 13:49:30.082 [main] - ==> Parameters: -500(Integer), 1(Integer) 
[DEBUG] 13:49:30.083 [main] - <==    Updates: 1 
[DEBUG] 13:49:30.084 [main] - Initiating transaction rollback 
[DEBUG] 13:49:30.084 [main] - Rolling back JDBC transaction on Connection [HikariProxyConnection@1498705150 wrapping com.mysql.cj.jdbc.ConnectionImpl@29ea78b1] 
[DEBUG] 13:49:30.094 [main] - Releasing JDBC Connection [HikariProxyConnection@1498705150 wrapping com.mysql.cj.jdbc.ConnectionImpl@29ea78b1] after transaction 
java.io.FileNotFoundException: aaa (系统找不到指定的文件。)
~~~





### 4.非public方法导致的事务失效

原因: Spring 为方法创建代理、添加事务通知、前提条件都是该方法是public的
解法:改为public方法 



### 5.父子容器导致的事务失效

原因:子容器扫描范围过大,把未加事务配置的service扫描进来【子容器中没有配置解析事务的相关bean，子容器扫到service就直接将其放到子容器中，但没有被相关的bean处理，没有开启事务；此时控制器通过依赖注入使用service,控制器在子容器中，子容器中又有service，就近原则到子容器中取这个service是没有事物的，所以就会出事】
父容器放 service mapper datasource 子容器放controller springMVC【相关配置】
解法1:各扫描各的,不要图简便
解法2:不要用父子容器,所有bean放在同一容器【springBoot就会把所有的bean放在同一个容器中】





- TestAccountService

~~~java
package day04.tx.app.service;

import day04.tx.AppConfig;
import day04.tx.WebConfig;
import day04.tx.app.controller.AccountController;
import org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.support.GenericApplicationContext;

import java.io.FileNotFoundException;

public class TestService5 {
    public static void main(String[] args) throws FileNotFoundException {
        //简单的applicationContext 作为父容器
        GenericApplicationContext parent = new GenericApplicationContext();
        //添加基本的bean 后处理器和 beanFactory 后处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(parent.getDefaultListableBeanFactory());
        ConfigurationPropertiesBindingPostProcessor.register(parent.getDefaultListableBeanFactory());
        //添加配置类
        parent.registerBean(AppConfig.class);
        //准备好容器
        parent.refresh();

        //简单的applicationContext 作为子容器
        GenericApplicationContext child = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(child.getDefaultListableBeanFactory());
        //设置父子容器关系
        child.setParent(parent);
        //添加一个与父容器不同的配置类
        child.registerBean(WebConfig.class);
        //准备好容器
        child.refresh();
        //透过子容器获取控制器
        AccountController bean = child.getBean(AccountController.class);
        bean.transfer(1, 2, 500);
    }
}
~~~



- AppConfig【父容器配置类】

~~~java
package day04.tx;

import com.zaxxer.hikari.HikariDataSource;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.*;
import org.springframework.core.io.ClassPathResource;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.jdbc.datasource.init.DataSourceInitializer;
import org.springframework.jdbc.datasource.init.DatabasePopulator;
import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.AnnotationTransactionAttributeSource;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.interceptor.TransactionAttributeSource;

import javax.sql.DataSource;

@Configuration//配置类
@PropertySource("classpath:jdbc.properties")//读取配置文件
@EnableTransactionManagement//申明式的事务管理
@EnableAspectJAutoProxy(exposeProxy = true)//开启了AOP
@ComponentScan("day04.tx.app.service")//spring包扫描
@MapperScan("day04.tx.app.mapper")//mybatis的包扫描
public class AppConfig {

    /*
     * 配置数据源
     * */
    @ConfigurationProperties("jdbc")
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }

    /*
     * 数据源的初始化器
     * */
    @Bean
    public DataSourceInitializer dataSourceInitializer(DataSource dataSource, DatabasePopulator populator) {
        DataSourceInitializer dataSourceInitializer = new DataSourceInitializer();
        dataSourceInitializer.setDataSource(dataSource);
        dataSourceInitializer.setDatabasePopulator(populator);
        return dataSourceInitializer;
    }

    /*
     * 每次初始化就会执行sql脚本 DDL 保证数据一致
     * */
    @Bean
    public DatabasePopulator databasePopulator() {
        return new ResourceDatabasePopulator(new ClassPathResource("account.sql"));
    }

    /*
     * 因为要使用到mybatis 所以要有sqlSessionFactory
     * */
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        return factoryBean;
    }

    /*
     * 配合Mybatis一起使用的事务管理器【申明式事务】
     * */
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean
    // 只要 beanFactory 的 allowBeanDefinitionOverriding==true, 即使系统的 @Bean 定义没有 @ConditionalOnMissingBean 条件，也会被我们的同名 @Bean 覆盖掉
    public TransactionAttributeSource transactionAttributeSource() {
        return new AnnotationTransactionAttributeSource(false);
    }
}
~~~



- WebConfig【子容器配置类】

~~~java
package day04.tx;

import org.springframework.context.annotation.ComponentScan;

@ComponentScan("day04.tx.app")//扫描到的包有service controller mapper
public class WebConfig {
}
~~~



- AccountController

~~~java
package day04.tx.app.controller;

import day04.tx.app.service.Service5;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import java.io.FileNotFoundException;

@Controller
public class AccountController {

    @Autowired
    public Service5 service;

    public void transfer(int from, int to, int amount) throws FileNotFoundException {
        service.transfer(from, to, amount);
    }
}
~~~



- AccountService

~~~java
package day04.tx.app.service;

import day04.tx.app.mapper.AccountMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.FileNotFoundException;

@Service
public class Service5 {

    @Autowired
    private AccountMapper accountMapper;

    @Transactional(rollbackFor = Exception.class)
    public void transfer(int from, int to, int amount) throws FileNotFoundException {
        int fromBalance = accountMapper.findBalanceBy(from);
        if (fromBalance - amount >= 0) {
            accountMapper.update(from, -1 * amount);
            accountMapper.update(to, amount);
        }
    }
}
~~~





### 6.调用本类方法导致传播行为失效

原因:本类方法调用不经过代理,因此无法增强
解法1:依赖注入自己(代理)来调用
解法2:通过AopContext 拿到代理对象,来调用
解法3:通过CTW, LTW 实现功能增强



- Service

~~~java
package day04.tx.app.service;

import day02.LoggerUtils;
import org.springframework.aop.framework.AopContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.io.FileNotFoundException;

@Service
public class Service6 {
    //自己注入自己有可能造成循环依赖
    //但此时从容器中得到的就是代理
    @Autowired
    private Service6 proxy;

    //传播行为【Propagation.REQUIRED】当此时没有事务就会创建新的事务，如果已经有事务了就会添加已有事务
    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
    public void foo() throws FileNotFoundException {
        LoggerUtils.get().debug("foo");
        System.out.println("调用通过依赖注入的自己：" + proxy.getClass());
        //proxy.bar();
        //bar();
        System.out.println("当前对象:" + this.getClass());
        //通过类型获取AOP代理对象，再调用代理对象的方法
        ((Service6) AopContext.currentProxy()).bar();
    }

    //是要有带有事务通知的代理对象调用该方法才能启用事务
    //一定会开启一个新的事务
    @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)
    public void bar() throws FileNotFoundException {
        LoggerUtils.get().debug("bar");
    }
}
=========================================
[INFO] 17:35:17.947 [main] - HikariPool-1 - Starting... 
[INFO] 17:35:18.065 [main] - HikariPool-1 - Start completed. 
class day04.tx.app.service.Service6$$EnhancerBySpringCGLIB$$8c911253
[DEBUG] 17:35:18.165 [main] - Creating new transaction with name [day04.tx.app.service.Service6.foo]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 17:35:18.165 [main] - Acquired Connection [HikariProxyConnection@1693799911 wrapping com.mysql.cj.jdbc.ConnectionImpl@71178a52] for JDBC transaction 
[DEBUG] 17:35:18.166 [main] - Switching JDBC Connection [HikariProxyConnection@1693799911 wrapping com.mysql.cj.jdbc.ConnectionImpl@71178a52] to manual commit 
[DEBUG] 17:35:18.170 [main] - foo 
调用通过依赖注入的自己：class day04.tx.app.service.Service6$$EnhancerBySpringCGLIB$$8c911253
当前对象:class day04.tx.app.service.Service6
[DEBUG] 17:35:18.171 [main] - Suspending current transaction, creating new transaction with name [day04.tx.app.service.Service6.bar] 
[DEBUG] 17:35:18.174 [main] - Acquired Connection [HikariProxyConnection@1676010932 wrapping com.mysql.cj.jdbc.ConnectionImpl@13a37e2a] for JDBC transaction 
[DEBUG] 17:35:18.174 [main] - Switching JDBC Connection [HikariProxyConnection@1676010932 wrapping com.mysql.cj.jdbc.ConnectionImpl@13a37e2a] to manual commit 
[DEBUG] 17:35:18.174 [main] - bar 
[DEBUG] 17:35:18.175 [main] - Initiating transaction commit 
[DEBUG] 17:35:18.175 [main] - Committing JDBC transaction on Connection [HikariProxyConnection@1676010932 wrapping com.mysql.cj.jdbc.ConnectionImpl@13a37e2a] 
[DEBUG] 17:35:18.175 [main] - Releasing JDBC Connection [HikariProxyConnection@1676010932 wrapping com.mysql.cj.jdbc.ConnectionImpl@13a37e2a] after transaction 
[DEBUG] 17:35:18.175 [main] - Resuming suspended transaction after completion of inner transaction 
[DEBUG] 17:35:18.175 [main] - Initiating transaction commit 
[DEBUG] 17:35:18.175 [main] - Committing JDBC transaction on Connection [HikariProxyConnection@1693799911 wrapping com.mysql.cj.jdbc.ConnectionImpl@71178a52] 
[DEBUG] 17:35:18.175 [main] - Releasing JDBC Connection [HikariProxyConnection@1693799911 wrapping com.mysql.cj.jdbc.ConnectionImpl@71178a52] after transaction 
~~~



- TestService

~~~java
package day04.tx.app.service;

import day04.tx.AppConfig;
import org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.support.GenericApplicationContext;

import java.io.FileNotFoundException;

public class TestService6 {

    public static void main(String[] args) throws FileNotFoundException {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());
        context.registerBean(AppConfig.class);
        context.refresh();

        Service6 bean = context.getBean(Service6.class);
        System.out.println(bean.getClass());
        bean.foo();
    }
}
~~~



### 7. @Transactional 没有保证原子行为

原因:事务的原子性涵盖insert, update, delete, select... for update 语句, select 方法并不阻塞
@Transaction 【多线程下会发生线程安全问题 指令交错，确实保证了更新原子性，总数不变，但数目到达负数，不符合逻辑】





- 问题体现
- TestService

~~~java
package day04.tx.app.service;

import day04.tx.AppConfig;
import org.slf4j.MDC;
import org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.support.GenericApplicationContext;

import java.util.concurrent.CountDownLatch;

public class TestService7 {

    public static void main(String[] args) throws InterruptedException {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());
        context.registerBean(AppConfig.class);
        context.refresh();

        Service7 bean = context.getBean(Service7.class);
        //锁
        CountDownLatch latch = new CountDownLatch(2);
        new MyThread(() -> {
            bean.transfer(1, 2, 1000);
            latch.countDown();
        }, "t1", "boldMagenta").start();

        new MyThread(() -> {
            bean.transfer(1, 2, 1000);
            latch.countDown();
        }, "t2", "boldBlue").start();

        //等到t1、t2都执行完毕才会继续执行
        latch.await();
        System.out.println(bean.findBalance(1));
    }

    static class MyThread extends Thread {
        private String color;

        public MyThread(Runnable target, String name, String color) {
            super(target, name);
            this.color = color;
        }

        @Override
        public void run() {
            MDC.put("thread", color);
            super.run();
            MDC.remove("thread");
        }
    }
}

~~~



- Service

~~~java
package day04.tx.app.service;

import day04.tx.app.mapper.AccountMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class Service7 {

    private static final Logger logger = LoggerFactory.getLogger(Service7.class);

    @Autowired
    private AccountMapper accountMapper;
    @Transactional(rollbackFor = Exception.class)
    //没有锁住事务提交的代码，即可以在事务提交前获取到没有更新的金额
    public synchronized void transfer(int from, int to, int amount) {
        int fromBalance = accountMapper.findBalanceBy(from);
        logger.debug("更新前查询余额为: {}", fromBalance);
        if (fromBalance - amount >= 0) {
            accountMapper.update(from, -1 * amount);
            accountMapper.update(to, amount);
        }
    }
    public int findBalance(int accountNo) {
        return accountMapper.findBalanceBy(accountNo);
    }
}
~~~





- 结果

~~~java
[DEBUG] 20:05:57.810 [t2] - Creating new transaction with name [day04.tx.app.service.Service7.transfer]:
[DEBUG] 20:05:57.810 [t1] - Creating new transaction with name [day04.tx.app.service.Service7.transfer]: 
[DEBUG] 20:05:57.812 [t2] - Acquired Connection [HikariProxyConnection@1235355069 wrapping com.mysql.cj.jdbc.ConnectionImpl@8b254bd] for JDBC transaction 
[DEBUG] 20:05:57.812 [t1] - Acquired Connection [HikariProxyConnection@1060226540 wrapping com.mysql.cj.jdbc.ConnectionImpl@7b50d1a8] for JDBC transaction 
[DEBUG] 20:05:57.813 [t2] - Switching JDBC Connection [HikariProxyConnection@1235355069 wrapping com.mysql.cj.jdbc.ConnectionImpl@8b254bd] to manual commit 
[DEBUG] 20:05:57.813 [t1] - Switching JDBC Connection [HikariProxyConnection@1060226540 wrapping com.mysql.cj.jdbc.ConnectionImpl@7b50d1a8] to manual commit 
[DEBUG] 20:05:57.826 [t1] - ==>  Preparing: select balance from account where accountNo=?  
[DEBUG] 20:05:57.842 [t1] - ==> Parameters: 1(Integer) 
[DEBUG] 20:05:57.868 [t1] - <==      Total: 1 
[DEBUG] 20:05:57.870 [t1] - 更新前查询余额为: 1000 
[DEBUG] 20:05:57.872 [t1] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:05:57.872 [t1] - ==> Parameters: -1000(Integer), 1(Integer) 
[DEBUG] 20:05:57.877 [t1] - <==    Updates: 1 
[DEBUG] 20:05:57.877 [t1] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:05:57.878 [t1] - ==> Parameters: 1000(Integer), 2(Integer) 
[DEBUG] 20:05:57.878 [t1] - <==    Updates: 1 
[DEBUG] 20:05:57.879 [t2] - ==>  Preparing: select balance from account where accountNo=?//t2在提交事务前查询了金额  
[DEBUG] 20:05:57.879 [t1] - Initiating transaction commit 
[DEBUG] 20:05:57.879 [t1] - Committing JDBC transaction on Connection //线程t1提交事务
[DEBUG] 20:05:57.879 [t2] - ==> Parameters: 1(Integer) 
[DEBUG] 20:05:57.879 [t2] - <==      Total: 1 
[DEBUG] 20:05:57.880 [t2] - 更新前查询余额为: 1000 
[DEBUG] 20:05:57.880 [t2] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:05:57.880 [t2] - ==> Parameters: -1000(Integer), 1(Integer) 
[DEBUG] 20:05:57.888 [t2] - <==    Updates: 1 
[DEBUG] 20:05:57.889 [t1] - Releasing JDBC Connection [HikariProxyConnection@1060226540 wrapping com.mysql.cj.jdbc.ConnectionImpl@7b50d1a8] after transaction 
[DEBUG] 20:05:57.889 [t2] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:05:57.889 [t2] - ==> Parameters: 1000(Integer), 2(Integer) 
[DEBUG] 20:05:57.890 [t2] - <==    Updates: 1 
[DEBUG] 20:05:57.890 [t2] - Initiating transaction commit 
[DEBUG] 20:05:57.890 [t2] - Committing JDBC transaction on Connection [HikariProxyConnection@1235355069 wrapping com.mysql.cj.jdbc.ConnectionImpl@8b254bd] 
[DEBUG] 20:05:57.891 [t2] - Releasing JDBC Connection [HikariProxyConnection@1235355069 wrapping com.mysql.cj.jdbc.ConnectionImpl@8b254bd] after transaction 
[DEBUG] 20:05:57.892 [main] - ==>  Preparing: select balance from account where accountNo=?  
[DEBUG] 20:05:57.892 [main] - ==> Parameters: 1(Integer) 
[DEBUG] 20:05:57.893 [main] - <==      Total: 1 
-1000
~~~



### 8. @Transactional 方法导致的 synchronized 失效

原因: synchronized 保证的仅是目标方法的原子性,环绕目标方法的还有commit等操作,它们并未处于sync块内
解法1: synchronized 范围应扩大至代理方法调用
解法2:使用 select... for update 替换 select 【从数据库层面上保证select原子性】



- 通过锁住代理类执行方法实现同步
- TestService

~~~java
package day04.tx.app.service;

import day04.tx.AppConfig;
import org.slf4j.MDC;
import org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.support.GenericApplicationContext;

import java.util.concurrent.CountDownLatch;

public class TestService7 {

    public static void main(String[] args) throws InterruptedException {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());
        context.registerBean(AppConfig.class);
        context.refresh();

        Service7 bean = context.getBean(Service7.class);
        Object lock = new Object();
        //锁
        CountDownLatch latch = new CountDownLatch(2);
        new MyThread(() -> {
            synchronized (lock) {
                bean.transfer(1, 2, 1000);
            }
            latch.countDown();
        }, "t1", "boldMagenta").start();

        new MyThread(() -> {
            synchronized (lock) {
                bean.transfer(1, 2, 1000);
            }
            latch.countDown();
        }, "t2", "boldBlue").start();

        //等到t1、t2都执行完毕才会继续执行
        latch.await();
        System.out.println(bean.findBalance(1));
    }

    static class MyThread extends Thread {
        private String color;

        public MyThread(Runnable target, String name, String color) {
            super(target, name);
            this.color = color;
        }

        @Override
        public void run() {
            MDC.put("thread", color);
            super.run();
            MDC.remove("thread");
        }
    }
}
~~~



- Service

~~~java
package day04.tx.app.service;

import day04.tx.app.mapper.AccountMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class Service7 {

    private static final Logger logger = LoggerFactory.getLogger(Service7.class);

    @Autowired
    private AccountMapper accountMapper;
    @Transactional(rollbackFor = Exception.class)
    public void transfer(int from, int to, int amount) {
        int fromBalance = accountMapper.findBalanceBy(from);
        logger.debug("更新前查询余额为: {}", fromBalance);
        if (fromBalance - amount >= 0) {
            accountMapper.update(from, -1 * amount);
            accountMapper.update(to, amount);
        }
    }
    public int findBalance(int accountNo) {
        return accountMapper.findBalanceBy(accountNo);
    }
}
~~~



- 结果

~~~java
[INFO] 20:32:57.676 [main] - HikariPool-1 - Starting... 
[INFO] 20:32:57.795 [main] - HikariPool-1 - Start completed. 
[DEBUG] 20:32:57.969 [t1] - Creating new transaction with name [day04.tx.app.service.Service7.transfer]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 20:32:57.970 [t1] - Acquired Connection [HikariProxyConnection@1175084298 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] for JDBC transaction 
[DEBUG] 20:32:57.971 [t1] - Switching JDBC Connection [HikariProxyConnection@1175084298 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] to manual commit 
[DEBUG] 20:32:57.984 [t1] - ==>  Preparing: select balance from account where accountNo=?  
[DEBUG] 20:32:58.000 [t1] - ==> Parameters: 1(Integer) 
[DEBUG] 20:32:58.021 [t1] - <==      Total: 1 
[DEBUG] 20:32:58.024 [t1] - 更新前查询余额为: 1000 
[DEBUG] 20:32:58.025 [t1] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:32:58.025 [t1] - ==> Parameters: -1000(Integer), 1(Integer) 
[DEBUG] 20:32:58.029 [t1] - <==    Updates: 1 
[DEBUG] 20:32:58.029 [t1] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:32:58.029 [t1] - ==> Parameters: 1000(Integer), 2(Integer) 
[DEBUG] 20:32:58.030 [t1] - <==    Updates: 1 
[DEBUG] 20:32:58.030 [t1] - Initiating transaction commit 
[DEBUG] 20:32:58.031 [t1] - Committing JDBC transaction on Connection [HikariProxyConnection@1175084298 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] 
[DEBUG] 20:32:58.034 [t1] - Releasing JDBC Connection [HikariProxyConnection@1175084298 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] after transaction 
[DEBUG] 20:32:58.034 [t2] - Creating new transaction with name [day04.tx.app.service.Service7.transfer]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 20:32:58.035 [t2] - Acquired Connection [HikariProxyConnection@1907265306 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] for JDBC transaction 
[DEBUG] 20:32:58.035 [t2] - Switching JDBC Connection [HikariProxyConnection@1907265306 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] to manual commit 
[DEBUG] 20:32:58.036 [t2] - ==>  Preparing: select balance from account where accountNo=?  
[DEBUG] 20:32:58.036 [t2] - ==> Parameters: 1(Integer) 
[DEBUG] 20:32:58.037 [t2] - <==      Total: 1 
[DEBUG] 20:32:58.037 [t2] - 更新前查询余额为: 0 
[DEBUG] 20:32:58.037 [t2] - Initiating transaction commit 
[DEBUG] 20:32:58.037 [t2] - Committing JDBC transaction on Connection [HikariProxyConnection@1907265306 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] 
[DEBUG] 20:32:58.038 [t2] - Releasing JDBC Connection [HikariProxyConnection@1907265306 wrapping com.mysql.cj.jdbc.ConnectionImpl@163dca8c] after transaction 
[DEBUG] 20:32:58.038 [main] - ==>  Preparing: select balance from account where accountNo=?  
[DEBUG] 20:32:58.039 [main] - ==> Parameters: 1(Integer) 
[DEBUG] 20:32:58.039 [main] - <==      Total: 1 
0
~~~



- for update

~~~java
[INFO] 20:40:53.572 [main] - HikariPool-1 - Starting... 
[INFO] 20:40:53.704 [main] - HikariPool-1 - Start completed. 
[DEBUG] 20:40:53.801 [t2] - Creating new transaction with name [day04.tx.app.service.Service7.transfer]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 20:40:53.801 [t1] - Creating new transaction with name [day04.tx.app.service.Service7.transfer]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.lang.Exception 
[DEBUG] 20:40:53.802 [t2] - Acquired Connection [HikariProxyConnection@1091314678 wrapping com.mysql.cj.jdbc.ConnectionImpl@50793d3a] for JDBC transaction 
[DEBUG] 20:40:53.804 [t2] - Switching JDBC Connection [HikariProxyConnection@1091314678 wrapping com.mysql.cj.jdbc.ConnectionImpl@50793d3a] to manual commit 
[DEBUG] 20:40:53.810 [t1] - Acquired Connection [HikariProxyConnection@1667859057 wrapping com.mysql.cj.jdbc.ConnectionImpl@69130d63] for JDBC transaction 
[DEBUG] 20:40:53.810 [t1] - Switching JDBC Connection [HikariProxyConnection@1667859057 wrapping com.mysql.cj.jdbc.ConnectionImpl@69130d63] to manual commit 
[DEBUG] 20:40:53.818 [t1] - ==>  Preparing: select balance from account where accountNo=? for update  
[DEBUG] 20:40:53.818 [t2] - ==>  Preparing: select balance from account where accountNo=? for update  //只要t1的事务没有提交t2的select语句就会阻塞，等待t1事务结束
[DEBUG] 20:40:53.835 [t1] - ==> Parameters: 1(Integer) 
[DEBUG] 20:40:53.835 [t2] - ==> Parameters: 1(Integer) 
[DEBUG] 20:40:53.857 [t2] - <==      Total: 1 
[DEBUG] 20:40:53.861 [t2] - 更新前查询余额为: 1000 
[DEBUG] 20:40:53.862 [t2] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:40:53.862 [t2] - ==> Parameters: -1000(Integer), 1(Integer) 
[DEBUG] 20:40:53.863 [t2] - <==    Updates: 1 
[DEBUG] 20:40:53.864 [t2] - ==>  Preparing: update account set balance=balance+? where accountNo=?  
[DEBUG] 20:40:53.864 [t2] - ==> Parameters: 1000(Integer), 2(Integer) 
[DEBUG] 20:40:53.864 [t2] - <==    Updates: 1 
[DEBUG] 20:40:53.865 [t2] - Initiating transaction commit 
[DEBUG] 20:40:53.865 [t2] - Committing JDBC transaction on Connection [HikariProxyConnection@1091314678 wrapping com.mysql.cj.jdbc.ConnectionImpl@50793d3a] 
[DEBUG] 20:40:53.881 [t2] - Releasing JDBC Connection [HikariProxyConnection@1091314678 wrapping com.mysql.cj.jdbc.ConnectionImpl@50793d3a] after transaction 
[DEBUG] 20:40:53.881 [t1] - <==      Total: 1 
[DEBUG] 20:40:53.882 [t1] - 更新前查询余额为: 0 
[DEBUG] 20:40:53.882 [t1] - Initiating transaction commit 
[DEBUG] 20:40:53.882 [t1] - Committing JDBC transaction on Connection [HikariProxyConnection@1667859057 wrapping com.mysql.cj.jdbc.ConnectionImpl@69130d63] 
[DEBUG] 20:40:53.882 [t1] - Releasing JDBC Connection [HikariProxyConnection@1667859057 wrapping com.mysql.cj.jdbc.ConnectionImpl@69130d63] after transaction 
[DEBUG] 20:40:53.882 [main] - ==>  Preparing: select balance from account where accountNo=? for update  
[DEBUG] 20:40:53.883 [main] - ==> Parameters: 1(Integer) 
[DEBUG] 20:40:53.884 [main] - <==      Total: 1 
0
~~~



## SpringMvc的执行流程

### 初始化阶段

1. 在Web容器第一次用到DispatcherServlet 的时候,会创建其对象【由WEB容器进行创建的或在SpringBoot中就有可能由spring容器创建】并执行init方法
2. init 方法内会更具spring配置文件，创建Spring Web容器,并调用容器refresh方法，初始化Spring容器
3. refresh 过程中会创建并初始化SpringMVC中的重要组件,例如MultipartResolver, HandlerMapping,HandlerAdapter, HandlerExceptionResolver,ViewResolver 等
4. 容器初始化后,会将上一步初始化好的重要组件,赋值给DispatcherServlet 的成员变量,留待后用



​		HandlerMapping:根据请求路径找到对应的控制器，把一个请求映射到控制器的一个方法调用上
​		HandlerAdapter：由该类的对象执行控制器中的方法
​		HandlerExceptionResolver：当执行控制器中的方法发生异常时，是由该类的对象
​		ViewResolver：负责将名字解析成视图对象，视图对象会根据实现，跳转到jsp或模板引擎，进行视图渲染
​		例如MultipartResolver：用于处理文件上传时，处理Multipart格式的表单



---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-04-01_20-53-03.png)

---





### 匹配阶段:

1. 用户发送的请求统一到达前端控制器DispatcherServlet【作为一个多请求的入口，不负责处理具体请求】
   2.DispatcherServlet 遍历所有的 HandlerMapping ,找到与路径匹配的处理器【有处理器对象处理请求】
    - HandlerMapping 有多,每HandlerMapping会返回不同的处理器对象【有不同实现】,谁先匹配,返回谁的处理器【一个请求由一个处理器处理】。其中能识别@RequestMapping的优先级最高
    - 对应 @RequestMapping的处理器对象是HandlerMethod,它包含了控制器对象和控制器方法信息，即它可以知道哪个控制器的哪个方法调用的它
    - 其中路径与处理器的映射关系在HandlerMapping初始化时就会建立好
2. 将HandlerMethod 连同匹配到的拦截器,生成调用链对象HandlerExecutionChain 返回【通过路径匹配找到一个处理器链，包含有处理器和拦截器s】
   4.遍历HandlerAdapter处理器适配器,找到能处理HandlerMethod 的适配器对象【不同的适配器所支持的处理器不一样】,开始调用 【处理器是通过适配器进行调用的】

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-04-01_21-30-27.png)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823214405224.png)

---



----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-04-01_21-40-40.png)

---



### 执行阶段

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-04-01_23-19-04.png)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-04-01_23-19-53.png)

---

在匹配阶段，准备好了HandlerExecutionChain对象【包含了多个拦截器对象和处理器】，以及执行处理器的适配器



1. 执行拦截器 preHandle 【由外到内依次执行拦截器，当返回值为true就会放行，执行后续调用，否则就会被拦截器拦截下来】
2. 由HandlerAdapter 用 HandlerMethod
   - 调用前处理不同类型的参数【通过反射调用某个类的某个方法 】
   - 调用后处理不同类型的返回值【看有无@ResponseBody，有转会成json形式的数据，并标记ModelAndView 已处理，不会进行视图渲染，直接返回json】

3. 第2步没有异常
   - 封装成ModelAndView，并返回【包含模型数据和视图相关信息】
   - 执行拦截器 postHandle方法【由内到外调用】
   - 解析视图,得到View对象,进行视图宣染【模型数据根据视图的实现不同，会存储到不同的位置，比如视图使用jsp实现的，那么就会将模型数据取出放到request作用域，视图从作用域中取出模型数据，渲染生成一个html返回】

4. 第2步有异常,进入HandlerExceptionResolver异常处理流程
5. 最后都会执行拦截器的afterCompletion方法【由内到外逐一调用】
6. 如果控制器方法标注了@ResponseBody注解,则在第2步,就会生成json结果,并标记ModelAndView 已处理,这样就不会执行第3步的视图宣染





## Spirng注解大全



### @Configuration

~~~java
package day04.boot;

import org.mybatis.spring.mapper.MapperScannerConfigurer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.GenericApplicationContext;

public class TestConfiguration {
    public static void main(String[] args) {
        //一个简单的spring容器的实现
        /*
         * ApplicationContext（spring容器）内部包含了一个重要的成员变量beanFactory
         * beanFactory中有一个重要的集合beanDefinitionMap存储用来创建bean的一切信息，键是bean的名字
         * 当没有添加beanFactory后处理器，则不能识别@Configuration注解，以及@Bean注解【只有myConfig这一个手动添加的hean】
         * */
        GenericApplicationContext context = new GenericApplicationContext();
        //使用spring提供的一个工具类，将spring日程工作所需要bean后处理器以及beanFactory后处理器注册到容器中
        //@internalConfigurationAnnotationProcessor这是加载进容器的一个beanFactory后处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
        context.registerBean("myConfig", MyConfig.class);
        context.refresh();
        System.out.println();
        //class day04.boot.TestConfiguration$MyConfig$$EnhancerBySpringCGLIB$$ecbe59a9已经被CGLIB增强了
        //System.out.println(context.getBean(MyConfig.class).getClass());
    }

    // 注意点3: @Configuration 默认会为标注的类生成代理, 其目的是保证 @Bean 方法相互调用时, 仍然能保证其单例特性【所以说不互相调用有@Bean注解的方法，可以省略@Configration 不规范】
    @Configuration
    //不会生成代理对象 为真就
    //@Configuration(proxyBeanMethods = false)
    //@MapperScan("aaa")
    // 注意点1: 配置类其实相当于一个工厂【bean】, 标注 @Bean 注解的方法相当于工厂方法
    /*
     * factoryBeanName = "myConfig"
     * factoryMethodName = "bean1"【实例工厂方法，先要有工厂对象，才会有工厂方法】
     * */
    static class MyConfig {
        // 注意点2: @Bean 不支持方法重载, 如果有多个重载方法, 仅有一个能入选为工厂方法【入参的个数越多，优先级越高】
/*        @Bean
        public Bean1 bean1(Bean2 bean2) {
            //当bean2作为入参时，所得到的bean2都是同一个对象
            System.out.println("bean1()");
            System.out.println(bean2);
            System.out.println(bean2);
            System.out.println(bean2);
            System.out.println("================");
            //但是当没有@Configuration注解，使用调用方法获取bean时，调用多少次方法就创建多少个单例
            //@Configuration标注的类，会在运行的时候为其生成一个代理对象；代理对象会先检查是否有该bean没有就创建，有就直接从容器中拿，就不会有多个单例的情况
            System.out.println(bean2());
            System.out.println(bean2());
            System.out.println(bean2());
            return new Bean1();
        }*/

        /*@Bean
        public Bean1 bean1(@Value("${java.class.version}") String a) {
            System.out.println("bean1(" + a + ")");
            return new Bean1();
        }

        @Bean
        public Bean1 bean1(@Value("${java.class.version}") String a, @Value("${JAVA_HOME}") String b) {
            System.out.println("bean1(" + a + ", " + b + ")");
            return new Bean1();
        }*/

/*        @Bean
        public Bean2 bean2() {
            System.out.println("bean2()");
            return new Bean2();
        }*/


        // 注意点4: @Configuration 中如果含有 BeanFactory 后处理器, 则实例工厂方法会导致 MyConfig 提前创建, 造成其依赖注入失败
        // 解决方法是该用静态工厂方法或直接为 @Bean 的方法参数依赖注入, 针对 MapperScanner 可以改用注解方式
        @Value("${java.class.version}")
        private String version;


        /*
         * MapperScannerConfigurer 实际上是 BeanFactoryPostProcessor bean工厂的后处理器
         * 又因为初始化容器的第五步是，创建 bean工厂的后处理器来实现对beanFactory的增强；这里的bean后处理器是一个实例方法，需要现有配置类对象
         * 此时各种bean后处理器【各种bean包括配置类对象，都是在11步创建的】还没有创建出来，@Value注解就没有人来解析就不能读取到信息
         * */
        /*
         * 解决方法一:把获取beanFactory后处理器的方法改为静态方法，这样配置类对象就不会提前初始化【推荐】
         * 解决方法二:把需要设值注入的成员变量改为方法参数
         * 解决方法三:仅针对 MapperScannerConfigurer 在配置类上添加@MapperScan("aaa") 这样不会导致配置类对象提前创建
         *
         * */
        @Bean
        public static MapperScannerConfigurer configurer() {
            MapperScannerConfigurer scanner = new MapperScannerConfigurer();
            scanner.setBasePackage("aaa");
            return scanner;
        }

        @Bean
        public Bean3 bean3() {
            System.out.println("bean3() " + version);
            return new Bean3();
        }
    }

    static class Bean1 {
    }

    static class Bean2 {
    }

    static class Bean3 {
    }
}

~~~



### @Import

~~~java
package day04.boot;

import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.*;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.type.AnnotationMetadata;

public class TestDeferredImport {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();
        beanFactory.setAllowBeanDefinitionOverriding(false); // 不允许同名定义覆盖【默认可以】
        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);
        context.registerBean(MyConfig.class);
        context.refresh();

        System.out.println(context.getBean(MyBean.class));
    }

    // 1. 同一配置类中, @Import 先解析  @Bean 后解析
    // 2. 同名定义, 默认后面解析的会覆盖前面解析的【看到的是配置类中同名方法的实现】
    // 3. 不允许覆盖的情况下, 如何能够让 MyConfig(主配置类) 的配置优先? (虽然覆盖方式能解决)
    // 4. DeferredImportSelector 最后工作, 可以简单认为先解析 @Bean, 再 Import
    @Configuration
    //将选择器中想要配置的bean放到比配置类要后的时机经行装配【只有当主配置没有配置的，才使用从属配置】
    @Import(MySelector.class)
    static class MyConfig { // 主配置 - 程序员编写的
        @Bean
        public MyBean myBean() {
            return new Bean1();
        }
    }

    static class MySelector implements DeferredImportSelector {

        @Override
        public String[] selectImports(AnnotationMetadata importingClassMetadata) {
            return new String[]{OtherConfig.class.getName()};
        }
    }

    @Configuration
    static class OtherConfig { // 从属配置 - 自动配置
        @Bean
        //没有同名的myBean时才会创建
        @ConditionalOnMissingBean
        public MyBean myBean() {
            return new Bean2();
        }
    }

    interface MyBean {

    }

    static class Bean1 implements MyBean {

    }

    static class Bean2 implements MyBean {

    }

}

~~~





## SpirngBoot自动装配原理

### @SpringBootApplication

~~~java
@SpringBootConfiguration@ComponentScan.excludeFilters -用来在组件扫描时进行排除,也会排除自动配置类@EnableAutoConfiguration@AutoConflgurationPackage - 用来记住扫描的起始包.@lmport(AutoConfigurationlmportSelector.class) 用来加载 META-INF/spring.factories 中的自动配置类
~~~





~~~java
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {@Filter(type = FilterType.CUSTOM,classes = {TypeExcludeFilter.class})
                                 , @Filter(type = FilterType.CUSTOM,classes = {AutoConfigurationExcludeFilter.class})})
public @interface SpringBootApplication 
~~~



### @SpringBootConfiguration

~~~
@Configuration
@Indexed
public @interface SpringBootConfiguration {}

区别：
@Configuration标注的配置类在整个应用程序中可以有多个；但@SpringBootConfigration在整个应用程序中只有一个
根据这个唯一的配置类来判断主配置类
~~~



### @ComponentScan

~~~java
可以扫描 有@Component、@Configuration、@Service、@Controller、@Repository
@ComponentScan(excludeFilters = {
//实现该接口（TypeExcludeFilter）的类，可以定义 排除一些能被扫描到的类，但又不希望这个类被装配到spring容器中的 规则
@Filter(type = FilterType.CUSTOM,classes = {TypeExcludeFilter.class),
//将SpringBoot自带的一些自动配置类排除，这些类不是通过组件扫描的方式加载到容器中的，而是通过@EnableAutoConfiguraion的@Import装配到spring容器中的                                     
@Filter(type = FilterType.CUSTOM,classes = {AutoConfigurationExcludeFilter.class)
}
~~~



### @EnableAutoConfiguration

~~~java
//记录它所标注的类所在的包 【System.out.println(AutoConfigurationPackages.get(context.getDefaultListableBeanFactory()));】
@AutoConfigurationPackage
/*
1.使主配置与从属配置解耦，不会通过主配置直接引用从属配置的类名，而是通过ImportSelector读取配置文件【classpath:META-INF/spring.factories
键是固定的 值可以有多个用逗号隔开 org.springframework.boot.autoconfigure.EnableAutoConfiguration=day04.boot.TestAutoConfiguration$OtherConfig
】中配置的默认配置类的类名，ImportSelector对象在工作时还会将SpringBoot自动配置的类都加载进容器中【通过配置文件添加类名的从属类是自己编写的类】
2.使得从属配置类的加载优先级最低 ，当主配置包含有与从属配置相同名字的bean时，优先使用主配置的，从属配置只作为默认实现
public class AutoConfigurationImportSelector implements DeferredImportSelector{}
/*
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {}
~~~





~~~java
package day04.boot;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.GenericApplicationContext;

import java.io.IOException;

public class TestAutoConfiguration {

    public static void main(String[] args) throws IOException {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());
//        context.getEnvironment().getPropertySources().addLast(new ResourcePropertySource("application.properties"));
        context.registerBean(MyConfig.class);
        context.refresh();

//        System.out.println(AutoConfigurationPackages.get(context.getDefaultListableBeanFactory()));

        for (String name : context.getBeanDefinitionNames()) {
            System.out.println(name);
        }

//        System.out.println(SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, EnableAutoConfiguration.class.getClassLoader()).stream()
//                .filter(name -> !name.equals(OtherConfig.class.getName())).map(name -> "\"" + name + "\"").collect(Collectors.joining(",","{","}")));
    }

    @Configuration
//    @AutoConfigurationPackage
    @EnableAutoConfiguration(excludeName = {"org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration", "org.springframework.boot.autoconfigure.aop.AopAutoConfiguration", "org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration", "org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration", "org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration", "org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration", "org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration", "org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration", "org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration", "org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration", "org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration", "org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration", "org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration", "org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration", "org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration", "org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration", "org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration", "org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration", "org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration", "org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration", "org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration", "org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration", "org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration", "org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration", "org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration", "org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration", "org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration", "org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration", "org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration", "org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration", "org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration", "org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration", "org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration", "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration", "org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration", "org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration", "org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration", "org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration", "org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration", "org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration", "org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration", "org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration", "org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration", "org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration", "org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration", "org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration", "org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration", "org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration", "org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration", "org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration", "org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration", "org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration", "org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration", "org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration", "org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration", "org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration", "org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration", "org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration", "org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration", "org.springframework.boot.autoconfigure.netty.NettyAutoConfiguration", "org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration", "org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration", "org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration", "org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration", "org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration", "org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration", "org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration", "org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration", "org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration", "org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration", "org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration", "org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration", "org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration", "org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration", "org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration", "org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration", "org.springframework.boot.autoconfigure.session.SessionAutoConfiguration", "org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration", "org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration", "org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration", "org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration", "org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration", "org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration", "org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration", "org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration", "org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration", "org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration", "org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration", "org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration", "org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration", "org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration", "org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration", "org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration", "org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration", "org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration", "org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration", "org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration", "org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration", "org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration", "org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration", "org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration", "org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration", "org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration", "org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration", "org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration", "org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration", "org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration", "org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration", "org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration", "org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration"})
//    @Import(OtherConfig.class)
    static class MyConfig { // 主配置
/*        @Bean
        public Bean1 bean1() {
            System.out.println("MyConfig bean1()");
            return new Bean1();
        }*/
    }

    @Configuration
    static class OtherConfig { // 从属配置(自动配置、默认配置)
        @Bean
        @ConditionalOnMissingBean
        public Bean1 bean1() {
            System.out.println("OtherConfig bean1()");
            return new Bean1();
        }
        @Bean
        public Bean2 bean2() {
            return new Bean2();
        }
    }

    static class Bean1 {

    }

    static class Bean2 {

    }
}
================================
OtherConfig bean1()
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
day04.boot.TestAutoConfiguration$MyConfig
org.springframework.boot.autoconfigure.AutoConfigurationPackages
day04.boot.TestAutoConfiguration$OtherConfig
bean1
bean2
~~~





~~~
@SpringBootConfiguration 
@ComponentScan.excludeFilters 
    - 用来在组件扫描时进行排除,也会排除自动配置类@EnableAutoConfiguration.
@AutoConfigurationPackage 
    - 用来记住扫描的起始包.
    -  @lmport(AutoConfigurationlmportSelector.class) 用来加载 META-INF/spring.factories 中的自动配置类
~~~





## Spring中有哪些设计模式【11】

### 1. Spring 中的 Singleton Bean 是否是单例模式?

~~~
请大家区分 singleton pattern 与 Spring 中的 singleton bean.
- 根据单例模式的目的Ensure a class only has one instance, and provide a global point of access to it.【确保一个类中只有一个实例，并且其提供一个全局的访问点】
- 显然Spring中的singleton bean 并非实现了单例模式, singleton bean只能保证每个容器内,相同id的bean单实例【若id不同则可以有多个该类的实例】【而且sprng中是可以有多个容器的，不同容器，相同的id，相同的类型，也会有不同的实例】
- 当然Spring 中也用到了单例模式,例如   org.springframework.transaction.TransactionDefinition#withDefaultsorg.springframework.aop.TruePointcut#INSTANCE org.springframework.aop.interceptor.Exposelnvocationlnterceptor#ADVISOR 
~~~



### 2. Spring 中的Builder

~~~
Separate the construction of a complex object from its representation so that the same construction process can create different representations【构建器负责对象创造前的准备，最终调用.Build方法创建对象】

它的主要亮点有三处:
    1.较为灵活的构建产品对象
    2.在不执行最后build方法前,产品对象都不可用
    3.构建过程采用链式调用,看起来比较爽
Spring 中体现Builder 模式的地方:
org.springframework.beans.factory.support.BeanDefinitionBuilder 	org.springframework.web.util.UriComponentsBuilder.org.springframework.http.ResponseEntity.HeadersBuilder org.springframework.http.ResponseEntity.BodyBuilder 
~~~



### 3. Spring 中的Factory Method

~~~
Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses【工厂方法模式，使得接口与实现相分离，降低耦合】
根据上面的定义, Spring 中的ApplicationContext与BeanFactory 中的getBean 都可以视为工厂方法,它隐藏了bean (产品)的创建过程和具体实现
Spring中其它工厂:.
org.springframework.beans.factory.FactoryBean.
@Bean 标注的静态方法【静态工厂方法】及实例方法【实例工厂方法】
ObjectFactory 及 ObjectProvider
前两种工厂主要封装第三方的bean的创建过程,后两种工厂可以推迟bean创建,解决循环依赖及单例注入多例等问题 
~~~



### 4. Spring 中的Adapter

~~~
Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces
典型的实现有两处:org.springframework.web.servlet.HandlerAdapter - 因为控制器实现有各种各样,比如有大家熟悉的.
@RequestMapping 标注的控制器实现.
传统的基于Controller接口(不是@Controller注解啊)的实现
.较新的基于RouterFunction接口的实现它们的处理方法都不一样,为了统一调用,必须适配为HandlerAdapter接口org.springframework.beans.factory.support.DisposableBeanAdapter - 因为销毁方法多种多样,因此都要适配为DisposableBean 来统一调用销毁方法. 
~~~



### 5. Spring 中的Composite

~~~
Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly
典型实现有:.org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.org.springframework.web.servlet.view.ViewResolverComposite
composite 对象的作用是,将分散的调用集中起来,统一调用入口,它的特征是,与具体干活的实现实现同一个接口,当调用 composite对象的接口方法时,其实是委托具体干活的实现来完成, 
~~~

