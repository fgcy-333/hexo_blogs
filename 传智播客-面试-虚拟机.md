---
title: 虚拟机
date: 2022-08-23 22:37:54
tags:
- 院校帮-面试
categories: 
- 视频学习笔记
index_img: /images/itcast.png
---

##  JVM内存结构

<!--more--> 

![image-20220823215451825](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823215451825.png)

1. 创建main线程（有JVM栈为其分配内存）
2. 看方法区中是否有main方法所属类的信息，没有就会触发类加载行为【将字节码文件的所有原始信息(类名，继承关系，成员变量，方法)都行加载进方法区】
3. 将方法区中的main方法提取到栈中运行
4. 遇到类查看方法区中是否有该类，如果没有就触发类加载
5. 方法中的局部变量占有的是当前线程的栈内存，对象占用的是堆内存
   虚拟机栈:在JVM规范中，方法分为本地方法和java方法，如hashcode是本地方法，study是java方法；但是，oracle的hotspot虚拟机没有实现此规范，只有一个JVM 			Stack；要使用本地方法就要通过本地方法接口调用本地库
   程序计数器:程序计数器用于记录当前线程执行到第几行代码，即使线程被切换了，回来的时候也能记住是从第几行代码开始恢复执行
   垃圾回收：当没有任何一个变量引用对象地址时，当内存不足时，就会触发垃圾回收gc，此时就会将没有被引用的对象所占的空间释放开
   解释器：cup只认识机器码，并不认识字节码，需要通过解释器对字节码进行翻译；
   即时编译器：即时编译器JIT负责发现热点代码，并将热点代码翻译成机器码，缓存起来的；等待下次有人调用这段代码时，直接从缓存中拿出机器码交给cpu执行，少了解释那一步，效率疯涨
   属于线程私有的内存结构有:程序计数器、虚拟机栈
   属于线程共享的内存结构有:堆和方法区



## 哪些部分会出现内存溢出

不会出现内存溢出的区域-程序计数器
出现OutOfMemoryError的情况

1. 堆内存耗尽-对象越来越多,又一直在使用,不能被垃圾回收
2. 方法区内存耗尽-加载的类越来越多,很多框架都会在运行期间动态产生新的类（可以给方法区的内存设置上限，超过这个上限就会出OutOfMemoryError）；但是默认不会设置上限，即物理内存有多大，方法区就有多大
3. 虚拟机栈累积-每个线程最多会占用1M内存,线程个数越来越多,而又长时间运行不销毁时【线程过多】出现StackOverflowError的情况虚拟机栈内部-方法调用次数过多(编程能力不足造成的，比如递归没有设置好出口)；溢出是因为每个线程最多占用1M内存，每次调用方法都需要从1M中拿部分内存，当线程内的1M内存用完了就会出现StackOverflowError【方法过多】





## 方法区与永久代、元空间之间的关系

方法区是【JVM规范】中定义的一块内存区域,用来存储类元数据、方法字节码、即时编译器需要的信息等
永久代是Hotspot虚拟机对JVM规范的实现(1.8之前)
元空间是Hotspot虚拟机对JVM规范的实现(1.8以后),使用本地内存作为这些信息的存储空间【物理内存有多大，方法区就有多大】

----

![image-20220823215942253](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823215942253.png)

---

当对象c不再被人引用时，Y这个类也没人在使用；此时队中的c对象，Y.class对象可以被垃圾回收；但此时Y类在元空间中的信息不可以被卸载；只有当整个类加载器不再被使用时，被它加载的类的元空间信息才会被卸载；
当内存不足，触发gc，将所有没人引用的对象清除掉；此时类加载器发现自己所有的类都被回收了，那它也会被回收；类加载器没了之后才会去将元空间中相关类的原始信息卸载掉
一般来说，系统的类加载器是没有机会被回收的，只有自定义的类加载器才有可能被回收





## 对于JVM内存配置参数

### 堆内存设置

~~~
-Xmx10240m -Xms10240m -Xmn5120m -XX:SurvivorRatio=3其最小内存值和Survivor区总大小分别是

-Xmx10240m：JVM最大内存是10G
-Xms10240m：JVM最小内存是10G
-Xmn5120m：JVM新生代内存是5G
SurvivorRatio=3：eden区比from区是3：1
survivor区包含from区和to区(1:1)
~~~

----

![image-20220823220056427](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823220056427.png)

---

最小内存是5G survivor内存大小为2G



---

![image-20220823220147367](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823220147367.png)

---





### 元空间内存分类

---

![image-20220823220319923](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823220319923.png)

---



class space：放置类的基本信息 类名，方法入口【包含两个表，itable和vtable】
non-class space：放置方法的字节码，类上的注解
-XX:CompressedClassSpaceSize:用来设置class-space区的上限大小，默认初始是一个G
--XX:MaxMetaspaceSize:最大元空间大小上限【默认是不设置的，即没有大小限制，物理硬盘有多大，原空间大小就有多大】



### 代码缓存

----

![image-20220823220442153](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823220442153.png)

---

JIT即时编译器:将热点代码编译成机器码缓存起来，缓存的地方就是CodeCache
当`-XX:ReservedCodeCacheSize<240m`时，会将所有的机器码放在一块
`当-XX:ReservedCodeCacheSize>=240m`时,会分为三个区域；
	1. non-nmthods:jit自己使用的一些代码
	2. prodflednmthods:部分优化后的代码
	3. non-profilednmthods:经过完整优化后的代码



### 线程内存

----

![image-20220823220526715](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823220526715.png)

----

控制每个线程占用的内存，64位的linux操作系统每个线程占用一兆内存



## JVM垃圾回收算法

1. 标记清除

---

![image-20220823220603957](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823220603957.png)

---

1. 找到GC Root对象(一定不能被回收的对象)【局部变量正在使用的对象，静态变量引用的对象】
2. 找根对象以及被根对象直接或间接引用的对象，给它加上标记
3. 有标记的对象给它保留下来，没有标记的对象直接给他清除

问题：
释放后的内存大概率时不连续的，造成内存碎片问题
当想要创建一片连续的空间时，发现内存还是不足
所以现在大部分的垃圾回收器都不使用标记清除算法





2. 标记整理

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-26_13-06-20.png)

---

1. 找到根对象以及根对象直接或间接引用的对象
2. 对这些对象进行标记
3. 将没有标记的对象释放掉
4. 将存活的对象向一边无缝隙靠拢(解决内存碎片问题)
   因为多了整理的步骤【发生内存复制，计算引用地址】所以效率变低





3. 标记复制

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-26_13-15-10.png)

----

FROM空间专门用来存储对象，TO空间一开始什么东西都不存

1. 找到GC Root对象以及被他们直接或间接引用的对象
2. 对这些对象进行标记
3. 将有标记的对象复制一份到TO(空闲区)【也不存在内存碎片问题】
4. 将FROM区中的对象全部释放掉
   问题
     空间换时间，内存占用多



- 小结

标记清除法，现在已经没有使用的
复制标记法比较适合新生代的垃圾回收【存活的对象少，清除的对象多】
复制标记法不适合老年代的垃圾回收【存活的对象多 ，清除的对象少】，所以老年代更适合标记整理法



## 说说GC和分代回收算法

GC的目的在于

1. 实现无用对象内存自动释放,
2. 减少内存碎片
3. 加快分配速度



GC要点:

       1. 回收区域是堆内存,不包括虚拟机栈,在方法调用结束会自动释放方法占用内存
       2. 判断无用对象,使用可达性分析算法【找到GC Root以及被它直接或间接引用的对象】,三色标记法标记存活对象,回收未标记对象
       3. GC具体的实现称为垃圾回收器【并行垃圾回收器，CMS垃圾回收器，GOne垃圾回收器】
       4. GC大都采用了分代回收思想,理论依据是大部分对象朝生夕灭,用完立刻就可以回收,另有少部分对象会长时间存活,每次很难回收,根据这两类对象的特性将回收区域分为新生代【朝生夕灭的对象，频繁运行GC】和老年代【长时间存活的对象，长间隔运行GC】,不同区域应用不同的回收策略
       5. 根据GC的规模可以分成 Minor GC【对新生代进行垃圾回收，小范围垃圾回收，暂停时间短，对系统影响较小】, Mixed GC【新生代发生垃圾回收，部分老年代也发生垃圾回收】, Full GC【对新生代和老年代都进行一次垃圾回收，暂停时间长，能明显感受到系统卡顿】



## 分代回收与GC规模

### 分代回收

伊甸园 eden,最初对象都分配到这里,与幸存区合称新生代
幸存区survivor,当伊甸园内存不足,回收后的幸存对象到这里,分成from 和to,采用标记复制算法
老年代old,当幸存区对象熬过(不确定)几次回收(最多15次,即熬过15次必晋升),晋升到老年代(幸存区内存不足或大对象会导致提前晋升)



- 1

---

![image-20220823220858278](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823220858278.png)

---



- 2

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-26_15-34-36.png)

---



- 3

---

![image-20220823221046921](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823221046921.png)

---



- 4

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-26_15-44-23.png)

---



### GC规模

1. Minor GC发生在新生代的垃圾回收,暂停时间短【上面演示的都是发生在新生代的Minor GC】
2. Mixed GC新生代(新生代全部回收一遍)+老年代部分区域(老年区划分为多个区域，挑其中回收价值较高的区域)的垃圾回收, G1收集器特有
3. Full GC新生代+老年代完整垃圾回收,暂停时间长,应尽力避免



## 三色标记与并发漏标问题

### 用三种颜色记录对象的标记状态

黑色-已标记
	沿着根对象找到的引用对象，并且该对象内部的其他引用也已经完成了标记
灰色-标记中
	沿着根对象找到的引用对象，但是该对象内部的其他引用还未被处理完【正在处理中】
白色-还未标记
	沿着根对象找到的引用对象，该对象没有被处理且该对象内部的其他引用也没被处理





- 总结

---

![image-20220823221225381](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823221225381.png)

---

正在处理的对象标记为灰色，被它引用的对象标记为白色
处理完成的对象标记为黑色，被它引用的对象标记为灰色
没有被处理的对象标记为白色，被它引用的对象标记为白色
沿着引用链进行迭代，最后将黑色标记的对象保留，将白色标记的对象清除



### 并发漏标问题

标记对象状态是使用垃圾回收线程执行的（垃圾回收线程）
用户编写的业务代码是在用户线程中运行的（用户线程）
在早期的垃圾回收器中，垃圾回收线程和用户线程是不能同时运行的，垃圾回收线程一但执行，用户线程就得马上停止
现在的垃圾回收器支持并发，但不是所有情况下都能并发  
一种典型的并发场景：老年代的垃圾回收器在进行标记的时候是可以并发的；





- 漏标问题-记录标记过程中变化

1. Incremental Update(增量更新)
   只要赋值发生,【被赋值的对象】就会被记录
   垃圾回收线程会记录所有的赋值动作，将被赋值的对象的标记改为灰色；
   当并发标记完成后，会让用户线程停止，对并发标记过程中，记录下来的 标记改变的对象进行处理(重新标记)
2. Snapshot At The Beginning(原始快照), SATB 
   新加对象会被记录
   被删除引用关系的对象也被记录 
   当并发标记完成后，会让用户线程停止，对并发标记过程中，记录下来的 标记改变的对象进行处理(重新标记)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-26_16-57-15.png)

---



## 垃圾回收器

### 1. Parallel GC（并行的垃圾回收）

有两个垃圾回收器组成:工作代&新生代、工作代老年代
特点：

1. eden 内存不足发生Minor GC(新生代),回收算法：标记复制STW(Stop ths work)应用程序暂停，暂停时间短
2. old 内存不足发生Full GC【新生代和老年代都要进行GC】,新生代使用的回收算法:标记复制法，暂停时间短；老年代使用的算法：标记整理STW，暂停时间长
3. 注重吞吐量
4. 虽然会暂停，但它会启动多个线程执行垃圾回收



### 2. ConcurrentMarkSweep GC

1. old并发标记【有漏标问题】,重新标记时需要STW,并发清除，标记和清除的时候用户线程和GC都可以同时运行，但是重新标记的时候必须停止用户线程【使用标记清除算法，有内存碎片问题】
2. Failback【并发失败的保底策略，并发速度小于对象创造速度就会失败，失败就会触发-----》 Full GC【stw停止用户线程，让新生代和老年代都进行一次彻底GC】
3. 注重响应时间
4. 在最新的jdk中把它标记为废弃



### 3. G1 GC

1. 响应时间与吞吐量兼顾，综合能力强
2. 将整个堆内存划分成多个大小相等的区域,每个区域都可以充当eden,survivor, old, humongous【存放大对象】
3. 新生代回收:eden 内存不足,标记复制STW
4. 并发标记:old并发标记,重新标记时需要STW
5. 混合收集(既有新生代的内存释放，又有老年代的内存释放):并发标记完成,开始混合收集,参与复制的有eden、survivor, old,其中 old会根据暂停时间目标,选择部分回收价值高的区域,复制时STW
6. Failback Full GC 

【jdk9默认的垃圾回收器】



- 新生代垃圾回收1

----

![image-20220823221538595](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823221538595.png)

---

1. 将整个堆内存划分为多个大小相等的区域，这些区域叫region，每个区域都可以充当eden,survivor, old, humongous
2. 当我们创建对象时就会挑选一些空的区域作为eden区
3. 随着对象越来越多，之前创建的eden区内存用完了【eden的大小会受到整个新生代的限制的，G1会自动调整新生代内存大小，有限制，在一定范围内波动】，触发GC
4. 垃圾回收算法采用标记复制算法，标记和复制的过程都会stw复制到survivor
5. 复制完成后可以将Eden区释放掉，是释放Eden区，不是仅仅释放对象



- 新生代垃圾回收2

---

![image-20220823221800589](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823221800589.png)

---

1. 当创建的对象越来越多，eden区的空间已经全部用完时，触发GC
2. 将Eden区和上一个survivor区的幸存者对象复制到新的survivor区中；当发现上一个survivor区中有对象满足晋升条件时，会晋升到老年代
3. 释放掉eden区和上一次的survivor区



- 并发标记1

----

![image-20220823221909009](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823221909009.png)

---

老年代的占比达到整个堆内存的45%以上
在老年代中寻找存活对象，对其做出标记，与用户线程并发执行【采用原始快照法，解决漏标问题】
在老年代中挑选存活对象少，回收价值高的区域进行回收,还有eden区，上一批survivor区，做一次垃圾回收；
eden区，survivor区中，存活下来的对象，复制到新的survivor区
上一批达到晋升条件的survivor区中的对象，和old区中存活的对象，复制到新的old区
释放掉eden区，survivor区，old区的内存
多次执行混合收集，逐步将old区的内存释放掉，然后循环执行新生代回收，并发标记，混合回收
当对象清除速度小于对象创造速度，就会触发保底策略，Full GC





## 项目什么情况下会内存溢出，怎么解决

### 误用线程池导致的内存溢出1

- Executors.newFixedThreadPool

~~~java
package day03;

import day02.LoggerUtils;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

// -Xmx64m
// 模拟短信发送超时，但这时仍有大量的任务进入队列导致内存溢出
public class TestOomThreadPool {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        LoggerUtils.get().debug("begin...");
        //不停创建任务提交到线程池中
        while (true) {
            //前两个任务由线程池的两个核心线程为其服务，后面提交的任务添加到阻塞队列中
            executor.submit(()->{
                try {
                    LoggerUtils.get().debug("send sms...");
                    //是对Thread.sleep方法的包装，实现是一样的，只是多了时间单位转换和验证，然而TimeUnit枚举成员的方法却提供更好的可读性
                    TimeUnit.SECONDS.sleep(30);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
------------------------Executors---------------------------------------------
 public static ExecutorService newFixedThreadPool(int nThreads) {
    //核心线程数=最大线程数，即 救急线程数0
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      //救急线程不工作多长时间就会被回收
                                      0L, TimeUnit.MILLISECONDS,
                                      //存放任务的阻塞队列，不填参数就是整数有多大，它的容量有多大
                                      //Integer.MAX_VALUE 0x7fffffff
                                      new LinkedBlockingQueue<Runnable>());
}


=======================
[DEBUG] 10:03:36.331 [main] - begin... 
[DEBUG] 10:03:36.333 [pool-1-thread-1] - send sms... 
[DEBUG] 10:03:36.333 [pool-1-thread-2] - send sms... 

Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"

进程已结束，退出代码为 1
~~~





- Executors.newCachedThreadPool

~~~java
package day03;

import day02.LoggerUtils;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


// 模拟发送大量短信，此时创建大量线程运行任务，导致系统线程数用完
public class TestOomThreadPool {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        LoggerUtils.get().debug("begin...");
        while (true) {
            executor.submit(() -> {
                try {
                    LoggerUtils.get().debug("send sms...");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
---------------------------Executors.newCachedThreadPool--------------------------------------
    public static ExecutorService newCachedThreadPool() {
    	//核心线程数量为0，救急线程数量为整数最大值
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      //救急线程不工作60秒就会被回收
                                      60L, TimeUnit.SECONDS,
                                      //创建一个只能容纳一个任务的队列
                                      new SynchronousQueue<Runnable>());
    }

===================================================
别跑这段代码，会死机
~~~





### 查询数据量太大导致的内存溢出

~~~java
package day03;

import org.openjdk.jol.info.ClassLayout;

import java.nio.charset.StandardCharsets;

// 演示对象的内存估算
public class TestOomTooManyObject {
    public static void main(String[] args) {
        // 【jol-core】对象本身内存仅包含对象头以及基本数据类型的成员变量的大小
        long a = ClassLayout.parseInstance(new Product()).instanceSize();
        System.out.println("对象本身内存仅包含对象头以及基本数据类型的成员变量的大小:(Product)" + a);
        String name = "联想小新Air14轻薄本 英特尔酷睿i5 14英寸全面屏学生笔记本电脑(i5-1135G7 16G 512G MX450独显 高色域)银";
        // 一个字符串占用内存【就只是字符串对象的对象头大小，不包含内容】
        long b = ClassLayout.parseInstance(name).instanceSize();
        System.out.println("对象本身内存仅包含对象头以及基本数据类型的成员变量的大小(String):" + b);
        String desc = "【全金属全面屏】学生商务办公，全新11代处理器，MX450独显，100%sRGB高色域，指纹识别，快充（更多好货）";
        // 一个字符串占用内存【就只是字符串对象的对象头大小，不包含内容】
        long c = ClassLayout.parseInstance(desc).instanceSize();
        System.out.println("对象本身内存仅包含对象头以及基本数据类型的成员变量的大小(String):" + c);
        //字节数组头以及基本数据类型的成员变量的大小16字节，加上存放数据的字节数组大小
        System.out.println("String对象头大小+数组对象头和属性大小+字节数组大小：(name)" + (16 + name.getBytes(StandardCharsets.UTF_8).length));
        System.out.println("String对象头大小+数组对象头和属性大小+字节数组大小：(desc)" + (16 + desc.getBytes(StandardCharsets.UTF_8).length));
        // 一个对象估算的内存
        long avg = a + b + c + 16 + name.getBytes(StandardCharsets.UTF_8).length + 16 + desc.getBytes(StandardCharsets.UTF_8).length;
        System.out.println("一个商品的大小：" + avg);
        // ArrayList 24【对象头以及基本数据类型的成员变量的大小24字节】, Object[] 16 【数组头以及基本数据类型的成员变量的大小16字节】共 40
        //一百万个商品对象+集合本身大小
        System.out.println("一百万个商品对象+集合本身大小:" + (1_000_000 * avg + 40) / 1024 / 1024 + "Mb");
    }

    static public class Product {
        private int id;
        private String name;
        private int price;
        private String desc;

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getPrice() {
            return price;
        }

        public void setPrice(int price) {
            this.price = price;
        }

        public String getDesc() {
            return desc;
        }

        public void setDesc(String desc) {
            this.desc = desc;
        }
    }
}
=========================================
# WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf
# WARNING: Unable to attach Serviceability Agent. sun.jvm.hotspot.memory.Universe.getNarrowOopBase()
对象本身内存仅包含对象头以及基本数据类型的成员变量的大小:(Product)32
对象本身内存仅包含对象头以及基本数据类型的成员变量的大小(String):24
对象本身内存仅包含对象头以及基本数据类型的成员变量的大小(String):24
String对象头大小+数组对象头和属性大小+字节数组大小：(name)144
String对象头大小+数组对象头和属性大小+字节数组大小：(desc)157
一个商品的大小：381
一百万个商品对象+集合本身大小:363Mb

进程已结束，退出代码为 0//不要findAll
~~~







### 动态生成类导致的内存溢出

~~~java
 package day03;

import groovy.lang.GroovyShell;

import java.io.FileReader;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicInteger;

// -XX:MaxMetaspaceSize=24m
// 模拟不断生成类, 但类无法卸载的情况
public class TestOomTooManyClass {
    //这个类的内部有一个自定义的类加载器，用于加载执行脚本的时候会动态生成类
    //只要类加载器存在，或类存在，或实例存在，那么在元空间中这个类将一直存在
    //又因为该引用该对象的变量用static修饰，所以这个对象将一直存在，它的成员变量类加载器也会一直存在，元空间中的类信息不会卸载，造成oom
    static GroovyShell shell = new GroovyShell();

    public static void main(String[] args) {
        AtomicInteger c = new AtomicInteger();
        while (true) {
            try (FileReader reader = new FileReader("script")) {
                //执行脚本的时候会动态生成类（每次都会生成一个）
                shell.evaluate(reader);
                System.out.println(c.incrementAndGet());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
=============================================
跑了2595就耗尽元空间
Exception in thread "main" java.lang.OutOfMemoryError: Metaspace
进程已结束，退出代码为 1
~~~





- 解决

~~~java
package day03;

import groovy.lang.GroovyShell;

import java.io.FileReader;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicInteger;

// -XX:MaxMetaspaceSize=24m
// 模拟不断生成类, 但类无法卸载的情况
public class TestOomTooManyClass {
    public static void main(String[] args) {
        AtomicInteger c = new AtomicInteger();
        while (true) {
            try (FileReader reader = new FileReader("script")) {
                //将类定义成局部变量，这个对象不会一直存在，当方法跑完了，这个对象就不会被使用
                //当堆内存不足触发GC时，会将这些没人使用的对象清除掉，此时，哪些动态生成的类，实例，加载这些类的类加载器全部被清除，会清除元空间这些类信息
                GroovyShell shell = new GroovyShell();
                //执行脚本的时候会动态生成类（每次都会生成一个）
                shell.evaluate(reader);
                System.out.println(c.incrementAndGet());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
======================================
跑到35546，一点事都没有
~~~



- 打开jconsole观察

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_11-49-55.png)

---







## 类加载过程

- 类加载过程分为三个阶段

  1. 加载

  2. 将类的字节码载入方法区,并创建 类.class对象(类对象)【加载到方法区中的字节码java代码是无法直接访问的，因为字节码里面的数据结构是采C++实现的】类对象存储在堆中
  3. 如果此类的父类|接口没有加载,先加载父类|接口
  4. 加载是懒惰执行 【当需要用到该类时，才会触发类加载】

  

  2. 连接

  3. 验证 验证类是否符合Class规范,合法性、安全性检查
  4. 准备 为static变量分配空间,设置默认值【赋值语句是在最后的初始化才执行的】
  5. 解析 将常量池的符号引用解析为直接引用 

  

  3. 初始化

  4. 执行静态代码块与非final静态变量的赋值【有final修饰的变量在准备阶段就会赋好值，在初始化时不会重复赋值】【没有final修饰的静态变量，其初始化在静态代码块中执行】
  5. 初始化是懒惰执行 【new 类】

  ~~~java
  public class TestLazy {
      private Class<?> studentClass;
      public static void main(String[] args) throws IOException {
          System.out.println("未用到 Student");
          //需要输入一行数据，否则阻塞
          System.in.read();
  
          System.out.println(Student.class);   // 关键代码1，会触发类加载
          System.out.println("已加载 Student");
          TestLazy testLazy = new TestLazy();
          testLazy.studentClass = Student.class;
          System.in.read();
  
          Student stu = new Student();        // 关键代码2，会触发类初始化
          System.out.println("已初始化 Student");
          System.in.read();
      }
  }
  =============================================================
  未用到 Student
  
  class day03.loader.Student
  已加载 Student
  ~~~

  

~~~
使用jdk17的一个调试工具:jhsdb.exe【观察内存状态】
C:\Users\fgcy>cd /d D:\sofeware\Idea\jdk-17.0.2\bin
D:\sofeware\Idea\jdk-17.0.2\bin>jhsdb.exe
    clhsdb              command line debugger
    hsdb                ui debugger
    debugd --help       to get more information
    jstack --help       to get more information
    jmap   --help       to get more information
    jinfo  --help       to get more information
    jsnap  --help       to get more information

D:\sofeware\Idea\jdk-17.0.2\bin>jhsdb.exe hsdb

-----------------------------------------------------
D:\sofeware\Idea\jdk-17.0.2\bin>jps
14000
2080 Launcher
21556 Jps
18296 RemoteMavenServer36
78412 TestLazy
~~~

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_14-15-58.png)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_14-09-48.png)

----

![image-20220823222155785](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823222155785.png)

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_14-14-15.png)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_14-17-00.png)

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_14-17-26.png)

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_14-18-43.png)

----



- 证明类的初始化才能给静态变量赋初始值

~~~java
//查看堆的范围
hsdb> universe
Heap Parameters:
garbage-first heap [Ox00000000ff000000, Ox0000000100000000] region size 1024K

//查看G1划分的许多Region的范围
hsdb> glregiondetails
Region Details:
Region: Ox00000000ff000000, Ox00000000ff100000, Ox00000000ff100000:01d
Region: Ox00000000ff100000, Ox00000000ff200000,Ox00000000ff200000:0ld
Region: Ox00000000ff200000, 0x00000000ff300000, Ox00000000ff300000:01d
Region: Ox00000000ff300000, Ox00000000ff371e00, Ox00000000ff400000:01d
Region: Ox00000000ff400000, 0x00000000ff400000,Ox00000000ff500000:Free
Region: Ox00000000ff500000, Ox00000000ff500000,Ox00000000ff600000: Free
Region: Ox00000000ff600000, 0x00000000ff600000,0x00000000ff700000:Free
Region: Ox00000000ff700000, Ox00000000ff700000,Ox00000000ff800000: Free
Region: Ox00000000ff800000, Ox00000000ff800000,Ox00000000ff900000: Free
Region: Ox00000000ff900000, Ox00000000ffa00000, Ox00000000ffa00000:Survivor
Region: Ox00000000ffa00000, 0x00000000ffa00000, Ox00000000ffbo0000: Free
Region: Ox00000000ffbo0000,0x00000000ffbo0000,Ox00000000ffco0000: Free
Region: Ox00000000ffc00000, Ox00000000ffco0000, Ox00000000ffdo0000: Free
Region: Ox00000000ffd00000, Ox00000000ffd00000, Ox00000000ffe00000: Free
Region: Ox00000000ffe00000, 0x00000000ffe2e240,0x00000000fff00000:Eden
//用于查看某个对象的信息（给对象地址）
hsdb> inspect Ox00000000fff389a8
instance of oop for java/lang/Class@ Ox00000000fff389a8 @ Ox00000000fff389a8 (size = 1 
a: 0//只是用static修饰，在初始化阶段赋值
b: 0//只是用static修饰，在初始化阶段赋值
c: 153//用static、final修饰，在连接阶段赋值
~~~

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_15-00-10.png)

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_15-00-46.png)

---





- 证明类对象属于堆内存

scanoops begin end 全类名 ：查找某个范围内某种类型的全部对象的地址
inspect 对象地址  ：查看对象的信息
因为随便跑一个程序，需要运行的类对象就会有上千个，要找一个类对象十分困难
所以将类对象赋给某个类的实例变量，找某个类的一两个实例比较容易，通过这个实例的成员方法定位类对象的地址
通过insptect 地址查看类对象信息



## 静态代码块原理



~~~java
package day03.loader;

public class Student {
    static int a = 0x77;
    static {
        System.out.println("Student.class init");
    }
    static int b = 0x88;
    
	//基本数据类型的常量不会出现在c-init方法中
    static final int c = 0x99;
    static final int m = Short.MAX_VALUE + 1;
    static final Object n = new Object();

    int d = 0x55;
    int e = 0x66;
}
~~~

~~~java
//将编译器编译后的字节码文件翻译成人类可读的形式
D:\learn\tencentClass\interview\interview\target\classes\day03\loader>javap -p -c -p Student.class
    
//编译器将所有静态代码的赋值语句，静态代码块中的语句，合并到一个静态方法中【按照原来的顺序存放】，该方法会在类的初始化时才会调用，名叫c-init
 static {};
    Code:
       0: bipush        119   				//准备了一个常数119
       2: putstatic     #18                 // Field a:I  将常数赋值给a
       5: getstatic     #21                 // Field java/lang/System.out:Ljava/io/PrintStream拿到一个静态变量printStream
       8: ldc           #27                 // String Student.class init  准备好一个字符串【从常量池中取出#27的常量】
      10: invokevirtual #29                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V  调用printStream的成员方法println，将字符串当成是参数传给println
      13: sipush        136					//准备一个常量 136
      16: putstatic     #35                 // Field b:I 将常数赋值给b
          
      19: new           #4                  // class java/lang/Object
      22: dup
      23: invokespecial #3                  // Method java/lang/Object."<init>":()V
      //上面三行语句，创建一个Object对象
      26: putstatic     #38                 // Field n:Ljava/lang/Object; 将Object对象赋值给变量n
      29: return

~~~

~~~java
//在申明变量时已经确定下来值，不用在后续的初始化中对其进行赋值
static final int c;
    descriptor: I
    flags: ACC_STATIC, ACC_FINAL
    ConstantValue: int 153

  static final int m;
    descriptor: I
    flags: ACC_STATIC, ACC_FINAL
    ConstantValue: int 32768

~~~



## final修饰基本数据类型变量原理

~~~java
package day03.loader;

import java.io.IOException;

public class TestFinal {
    public static void main(String[] args) throws IOException {
        // c 是 final static 基本类型,不会触发Student类加载
        System.out.println(Student.c);
        System.in.read();

        // m 是 final static 基本类型不会触发类加载
        System.out.println(Student.m);
        System.in.read();

        // n 是 final static 引用类型，即会导致Student类的加载 又会导致Student类的初始化
        System.out.println(Student.n);
        System.in.read();
    }
}
--------------------------------------------------------------------------------
package day03.loader;

public class Student {
    static int a = 0x77;
    static {
        System.out.println("Student.class init");
    }
    static int b = 0x88;

    static final int c = 0x99;
    static final int m = Short.MAX_VALUE + 1;
    static final Object n = new Object();

    int d = 0x55;
    int e = 0x66;
}
~~~



方法区中类的原始信息(Student)

~~~java
//类的名字  
public class day03.loader.Student @0x0000000800c01a00
View Class Hierarchy
Create .class File
    
//类继承的父类|接口    
Super Class
public class java.lang.Object @0x0000000800000d58
  
//类的成员(静态成员、实例成员)    
Fields
static int a; (offset = 116)
static int b; (offset = 120)
static final int c; (offset = 124)
static final int m; (offset = 128)
static final java.lang.Object n; (offset = 112)
int d; (offset = 12)
int e; (offset = 16)

//类的方法
Methods
public void <init>() @0x0000026d6cc06058;
static void <clinit>() @0x0000026d6cc06108;

//类的常量池
Constant Pool
Constant Pool of [public class day03.loader.Student @0x0000000800c01a00] @0x0000026d6cc03d58
~~~



- 基本数据类型的常量不会触发类加载

~~~java
package day03.loader;

import java.io.IOException;

public class TestFinal {
    public static void main(String[] args) throws IOException {
        // c 是 final static 基本类型,不会触发Student类加载
        System.out.println(Student.c);
        System.in.read();

        // m 是 final static 基本类型不会触发类加载
        System.out.println(Student.m);
        System.in.read();

        // n 是 final static 引用类型，即会导致Student类的加载 又会导致Student类的初始化
        System.out.println(Student.n);
        System.in.read();
    }
}

~~~

~~~java
Constant pool:
   #1 = Methodref          #2.#3          // java/lang/Object."<init>":()V
     .......
  #30 = Utf8               ()I
  #31 = Integer            32768
  #32 = Fieldref           #13.#33        // day03/loader/Student.n:Ljava/lang/Object;
 .................
  #54 = Utf8               TestFinal.java
 
public static void main(java.lang.String[]) throws java.io.IOException;
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;//获取一个printStream对象
         3: sipush        153				  //准备一个常量，写死在main方法中
         6: invokevirtual #15                 // Method java/io/PrintStream.println:(I)V 调用printStream对象的println方法
         9: getstatic     #21                 // Field java/lang/System.in:Ljava/io/InputStream;///获取一个InputStream对象
        12: invokevirtual #25                 // Method java/io/InputStream.read:()I 调用inputstream的read方法
        15: pop
        16: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        19: ldc           #31                 // int 32768   从常量池中获取#31的常量
~~~



- 小结

1. 每个类都有自己的常量池
2. 一个类使用另一个类的基本数据类型的常量，不会对目标类进行类加载包括后续行为，因为他会将本类中要使用目标类的基本常量写死到代码中，或存储到常量池中
3. 如果数值<=short的范围，直接写死在代码中，否则放入该类的常量池中
4. short(32768 ~ -1,0 ~ 32767)



## 双亲委派

所谓的双亲委派,就是指优先委派上级类加载器进行加载,如果上级类加载器
能找到这个类,由上级加载,加载后该类也对下级加载器可见【对上级不可见】
找不到这个类,则下级类加载器才有资格执行加载 
直接层层往上报，到Bootstrap ClassLoader 如果有就直接加载，对下级可见；没有就权力下放给Extension ClassLoader加载 如果有就加载，对下级可见，没有就将权力下放给Application ClassLoader加载



---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_20-10-09.png)

---

启动类加载器  tr.jar 

扩展类加载器
应用程序加载器
自定义类加载器



- 自己编写类加载器就能加载一个假冒的java.lang.System 【不能】

1. 假设你自己的类加载器用双亲委派,那么优先由启动类加载器加载真正的java.lang.System,自然不会加载假冒的
2. 假设你自己的类加载器不用双亲委派,那么你的类加载器加载假冒的java.lang.System 时,它需要先加载父类java.lang.Object,而你没有用委派,找不到java.lang.Object所以加载会失败

以上也仅仅是假设。实际操作你就会发现自定义类加载器加载以java.打头的类时,会抛安全异常,在jdk9以上版本这些特殊包名都与模块进行了绑定,更连编译都过不了



- 双亲委派的目的有两点

让上级类加载器中的类对下级共享(反之不行),即能让你的类能依赖到jdk提供的核心类
让类的加载有忧先次序,保证核心类优先加载





## 对象引用类型分为哪几类

1. 强引用

只要用赋值运算符让变量引用对象都是强引用，A a=new A();
通过GC Root的引用链,如果强引用不到该对象,该对象才能被回收

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_21-02-08.png)

---



2. 软引用(SoftReference)

例如: SoftReference a = new SoftReference(new A());【变量直接引用软引用，软引用里面包装类其他对象】
如果仅有软引用该对象时,首次垃圾回收不会回收该对象,如果内存仍不足,再次回收时才会释放对象；【GC可以强行断开软引用包装的对象与变量之间的关系】
软引用自身需要配合引用队列来释放【GC不能断开变量与软引用对象之间的关系】
典型例子是反射数据 

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_21-02-37.png)

----



3. 弱引用(WeakReference)

例如: WeakReference a = new WeakReference(new A());
如果仅有弱引用引用该对象时,只要发生垃圾回收,就会释放该对象
弱引用自身需要配合引用队列来
释放典型例子是ThreadLocalMap 中的Entry对象 key与key的值之间是弱引用

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-27_21-03-02.png)

---





4. 虚引用(PhantomReference)

例如: PhantomReference a = new PhantomReference(newA());
必须配合引用队列一起使用,当虚引用引用的对象被回收时,会将虚引用对象入队,由Reference Handler线程释放其关联的外部资源
典型例子是Cleaner释放DirectByteBuffer 占用的直接内存 

---

![image-20220823223533970](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/image-20220823223533970.png)

---



### 虚引用

~~~java
package day03.reference;

import day02.LoggerUtils;

import java.io.IOException;
import java.lang.ref.*;
import java.util.ArrayList;
import java.util.List;

public class TestPhantomReference {
    public static void main(String[] args) throws IOException, InterruptedException {
        //引用队列
        ReferenceQueue<String> queue = new ReferenceQueue<>();
        List<MyResource> list = new ArrayList<>();
        list.add(new MyResource(new String("a"), queue));
        //"b"是在字符串常量池中的，GC不会清除它
        list.add(new MyResource("b", queue));
        list.add(new MyResource(new String("c"), queue));
        // 主动触发垃圾回收
        System.gc();
        Thread.sleep(100);
        Object ref;
        //从队列中取元素
        while ((ref = queue.poll()) != null) {
            //这个因该是相当于MyResource resource =(MyResource)resource
            if (ref instanceof MyResource resource) {
                resource.clean();
            }
        }
    }

    static class MyResource extends PhantomReference<String> {
        public MyResource(String referent, ReferenceQueue<? super String> q) {
            /*
                Reference(T referent, ReferenceQueue<? super T> queue) {
                //虚引用对象引用的对象
                this.referent = referent;
                //虚引用对象引用的对象被垃圾回收后，虚引用对象需要进入的队列
                this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
                 }
            * */
            super(referent, q);
        }

        // 释放外部资源的方法
        public void clean() {
            LoggerUtils.get().debug("clean");
        }
    }
}
=====================================
[DEBUG] 21:13:58.130 [main] - clean 
[DEBUG] 21:13:58.131 [main] - clean 
    
进程已结束，退出代码为 0
~~~



### 弱引用

~~~java
package day03.reference;

import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;

public class TestWeakReference {

    public static void main(String[] args) {
        MyWeakMap map = new MyWeakMap();
        map.put(0, new String("a"), "1");
        map.put(1, "b", "2");
        map.put(2, new String("c"), "3");
        map.put(3, new String("d"), "4");
        System.out.println(map);

        System.gc();
        System.out.println("键为a的value是：" + map.get("a"));
        System.out.println("键为b的value是：" + map.get("b"));
        System.out.println("键为c的value是：" + map.get("c"));
        System.out.println("键为d的value是：" + map.get("d"));
        System.out.println("gc后的map是：" + map);
        map.clean();
        System.out.println(map);
    }

    // 模拟 ThreadLocalMap 的内存泄漏问题以及一种解决方法
    static class MyWeakMap {
        //jdk的ThreadLoalMap没有用这队列
        //存放弱引用的引用队列
        static ReferenceQueue<Object> queue = new ReferenceQueue<>();

        //弱引用类  table————————》entry--------------》String
        static class Entry extends WeakReference<String> {
            String value;

            public Entry(String key, String value) {
                //键是弱引用，当key的值(对象)被释放后，会将当前Entry实例放到队列中
                super(key, queue);
                //值是强引用
                this.value = value;
            }
        }

        public void clean() {
            Object ref;
            while ((ref = queue.poll()) != null) {
                System.out.println(ref);
                //遍历Entry数组
                for (int i = 0; i < table.length; i++) {
                    //只要引用队列中的Entry对象，与table中的entry对象是同一个就可以将该table元素设置为null
                    if (table[i] == ref) {
                        //table 与多个entry之间的强引用就没了，下次GC就可以清除
                        table[i] = null;
                    }
                }
            }
        }

        Entry[] table = new Entry[4];

        public void put(int index, String key, String value) {
            table[index] = new Entry(key, value);
        }

        public String get(String key) {
            for (Entry entry : table) {
                if (entry != null) {
                    //通过弱引用的get方法获取用弱引用包装的对象【键的值】
                    String k = entry.get();
                    if (k != null && k.equals(key)) {
                        return entry.value;
                    }
                }
            }
            return null;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            for (Entry entry : table) {
                if (entry != null) {
                    String k = entry.get();
                    sb.append(k).append(":").append(entry.value).append(",");
                }
            }
            if (sb.length() > 1) {
                sb.deleteCharAt(sb.length() - 1);
            }
            sb.append("]");
            return sb.toString();
        }
    }
}
===================================================================
[a:1,b:2,c:3,d:4]
键为a的value是：null
键为b的value是：2
键为c的value是：null
键为d的value是：null
gc后的map是：[null:1,b:2,null:3,null:4]
day03.reference.TestWeakReference$MyWeakMap$Entry@621be5d1
day03.reference.TestWeakReference$MyWeakMap$Entry@573fd745
day03.reference.TestWeakReference$MyWeakMap$Entry@15327b79
[b:2]
~~~



### Cleaner



~~~java
package day03.reference;

import day02.LoggerUtils;

import java.io.IOException;
import java.lang.ref.Cleaner;

// 前面讲的弱、虚引用配合引用队列，目的都是为了找到哪些 java对象被回收，确定弱引用对象，从而进行对它们关联的资源进行进一步清理

/**
 * 为了简化 api 难度，从 java 9 开始引入了 Cleaner 对象，cleaner对象里面其实也是一些虚引用，弱引用，引用队列；但它专门开辟了一个线程用于对在引用队列中的引用释放相关资源
 */
public class TestCleaner1 {
    public static void main(String[] args) throws IOException {
        Cleaner cleaner = Cleaner.create();
        //第一个参数是可能被GC回收的资源，第二个参数是回收之后执行的逻辑
        cleaner.register(new MyResource(), () -> LoggerUtils.get().debug("clean 1"));
        cleaner.register(new MyResource(), () -> LoggerUtils.get().debug("clean 2"));
        cleaner.register(new MyResource(), () -> LoggerUtils.get().debug("clean 3"));
        MyResource obj = new MyResource();
        cleaner.register(obj, () -> LoggerUtils.get().debug("clean 4"));
        cleaner.register(new MyResource(), () -> LoggerUtils.get().debug("clean 5"));
        cleaner.register(new MyResource(), () -> LoggerUtils.get().debug("clean 6"));

        System.gc();

        //执行回收后逻辑的线程是守护线程，如果main线程执行完毕，守护线程也会结束
        System.in.read();
    }

    static class MyResource {
    }
}
======================================
[DEBUG] 23:38:15.732 [Cleaner-0] - clean 6 
[DEBUG] 23:38:15.733 [Cleaner-0] - clean 5 
[DEBUG] 23:38:15.734 [Cleaner-0] - clean 3 
[DEBUG] 23:38:15.734 [Cleaner-0] - clean 2 
[DEBUG] 23:38:15.734 [Cleaner-0] - clean 1 
~~~



~~~~java
package day03.reference;

import day02.LoggerUtils;

import java.io.IOException;
//jdk内部使用的类(直接内存会使用到这个类)
import jdk.internal.ref.Cleaner;

public class TestCleaner2 {
    public static void main(String[] args) throws IOException {
        Cleaner cleaner1 = Cleaner.create(new MyResource(), () -> LoggerUtils.get().debug("clean 1"));
        Cleaner cleaner2 = Cleaner.create(new MyResource(), () -> LoggerUtils.get().debug("clean 2"));
        Cleaner cleaner3 = Cleaner.create(new MyResource(), () -> LoggerUtils.get().debug("clean 3"));
        Cleaner cleaner4 = Cleaner.create(new MyResource(), () -> LoggerUtils.get().debug("clean 4"));

        System.gc();
        System.in.read();
    }

    static class MyResource {
    }
}
==================================
//不会调参数
~~~~



## finalize的理解

一般的回答是:它是Object中的一个方法,子类重写它,垃圾回收子类对象时，子类对象重写的finalize方法会被调用,可以在其中进行一些资源释放和清理工作
较为优秀的回答是:将资源释放和清理放在finalize方法中非常不好,非常影响性能,严重时甚至会引起0OM,从Java9 开始就被标注为@Deprecated,不建议被使用了



- 代码体现

~~~java
package day03.reference;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

public class TestFinalize {
    private static Logger fgcy = LoggerFactory.getLogger("fgcy");

    static class Dog {
        private String name;

        public Dog(String name) {
            this.name = name;
        }

        //重写Objcet类的finalize方法，当该对象被GC回收时，会先掉调用该方法，再回收对象
        @Override
        protected void finalize() throws Throwable {
            fgcy.debug("{}被干掉了?", this.name);
            //如果将 finalize 中的代码出现异常，会发现根本没有异常输出
            int i = 1 / 0;
        }
    }

    public static void main(String[] args) throws IOException {
        new Dog("大傻");
        new Dog("二哈");
        new Dog("三笨");
        System.gc();
        //运行finalize方法的Finalizer线程是一个守护线程，当main线程不再运行时，Finalizer线程也会消亡
        //使主线程处于等待状态
        System.in.read();
    }
    /*
    第一，从表面上我们能看出来 finalize 方法的调用次序并不能保证,因为我们不能决定gc回收对象的顺序
    第二，日志中的 Finalizer 表示输出日志的线程名称，从这我们看出是这个叫做 Finalizer 的线程调用的 finalize 方法
    第三，你不能注释掉 `System.in.read()`，否则会发现（绝大概率）并不会有任何输出结果了，从这我们看出 finalize 中的代码并不能保证被执行
    第四，如果将 finalize 中的代码出现异常，会发现根本没有异常输出
    第五，还有个疑问，垃圾回收时就会立刻调用  finalize 方法吗？
     */
}
======================================
[DEBUG] 17:14:39.577 [Finalizer] - 二哈被干掉了? 
[DEBUG] 17:14:39.580 [Finalizer] - 三笨被干掉了? 
[DEBUG] 17:14:39.580 [Finalizer] - 大傻被干掉了? 
~~~



## finalize的执行原理

~~~java
//1. 创建狗对象  
new Dog("大傻");
//2.调用父类Object构造器
public Object() {}

//3. 通过finalizer类的register方法，将狗对象包装成Finalizer对象
static void register(Object finalizee) {
     new Finalizer(finalizee);
}
//4. 初始化finalizer对象，并将其添加到链表中
private Finalizer(Object finalizee) {
        super(finalizee, queue);
        // push onto unfinalized
        synchronized (lock) {
            if (unfinalized != null) {
                this.next = unfinalized;
                unfinalized.prev = this;
            }
            //unfinalized是一个双向链表，用于存储finalizer对象
            //unfinalized就是一个finalizer类型的实例，用于管理所有重写了finalized方法的对象
            unfinalized = this;
        }
    }

//5. 创建一个名为Finalizer的守护线程
 private static class FinalizerThread extends Thread {
        private volatile boolean running;
        FinalizerThread(ThreadGroup g) {
            super(g, null, "Finalizer", 0, false);
        }
     //线程主要是从引用队列中拿出jvm想要清除的狗对象关联的finalizer对象
        public void run() {
            // in case of recursive call to run()
            if (running)
                return;

            // Finalizer thread starts before System.initializeSystemClass
            // is called.  Wait until JavaLangAccess is available
            while (VM.initLevel() == 0) {
                // delay until VM completes initialization
                try {
                    VM.awaitInitLevel(1);
                } catch (InterruptedException x) {
                    // ignore and continue
                }
            }
            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
            running = true;
            for (;;) {
                try {
                    //拿出jvm想要清除的狗对象关联的finalizer对象
                    Finalizer f = (Finalizer)queue.remove();
                    //操作finalizer对象
                    f.runFinalizer(jla);
                } catch (InterruptedException x) {
                    // ignore and continue
                }
            }
        }
    }
	//操作finalizer对象
    private void runFinalizer(JavaLangAccess jla) {
        //将finialzer对象从unfianlized双列表中断开
        synchronized (lock) {
            if (this.next == this)      // already finalized
                return;
            // unlink from unfinalized
            if (unfinalized == this)
                unfinalized = this.next;
            else
                this.prev.next = this.next;
            if (this.next != null)
                this.next.prev = this.prev;
            this.prev = null;
            this.next = this;           // mark as finalized
        }

        try {
            Object finalizee = this.get();
            assert finalizee != null;
            if (!(finalizee instanceof java.lang.Enum)) {
                
               //调用finalizee(狗对象)的finalized方法
                jla.invokeFinalize(finalizee);

                // Clear stack slot containing this variable, to decrease
                // the chances of false retention with a conservative GC
                finalizee = null;
            }
            //当发生异常时什么也不做，俗称把异常吞了，调用者甚至不知道有没有释放资源
        } catch (Throwable x) { }
        super.clear();
    }
~~~

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-29_17-57-46.png)

---



- unfinalized队列

当重写了finalize方法的对象,在构造方法调用之时,JVM都会将其包装成一个Finalizer 对象,并加入 unfinalized 队列中(静态成员变量、双向链表结构) 

---

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-29_19-37-23.png)

---



- ReferenceQueue队列

第二个重要的队列,也是Finalizer类中一个静态成员变量,名为queue(是一个单向链表结构),刚开始它是空的。当狗对象可以被当作垃圾回收时,就会把这些狗对象对应的Finalizer 对象加入这个队列，但注意，此时狗对象并没有被回收，因为还要调用finalized方法；等下一次内存不足触发GC这些狗对象才有可能被清除掉



### 真正回收时机

----

![](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/Snipaste_2022-03-29_20-01-43.png)

---

即使Dog对象没人引用,垃圾回收时也没法立刻回收它,因为Finalizer还在引用它嘛,为的是【先别着急回收啊,等我调完finalize方法,再回收】
查看FinalizerThread 线程内的代码,这个线程从ReferenceQueue 中逐一取出每个Finalizer对象,把它们从链表断开,这样没谁能引用到它,以及其对应的狗对象,所以下次gc时就可以被回收了。



## 为什么finalize方法非常不好,非常影响性能

### 非常不好

1. FinalizerThread 是守护线程,代码很有可能没来得及执行完,线程就结束了,造成资源没有正确释放
2. 异常被吞掉这个就太糟了,你甚至不能判断有没有在释放资源时发生错误.



### 影响性能

1. 重写了finalize 方法的对象在第一次被gc时,并不能及时释放它占用的内存,因为要等着FinalizerThread 调用完finalize,把它从第一个unfinalized队列移除后,第二次gc时才能真正释放内存
2. 可以想象gc本就因为内存不足引起,finalize 调用又很慢(两个队列的移除操作,都是串行执行的,用来释放连接类的资源也应该不快),不能及时释放内存,对象释放不及时就会逐渐移入老年代,老年代垃圾积累过多就会容易full gc, full gc后释放速度如果仍跟不上创建新对象的速度,就会OOM
   质疑



### 质疑

有的文章提到【Finalizer线程会和我们的主线程进行竞争,不过由于它的优先级较低,获取到的CPU时间较少,因此它永远也赶不上主线程的步伐】这个显然是错误的, FinalizerThread的优先级较普通线程更高,赶不上步伐的原因应该是finalize执行慢等原因综合导致



~~~java
 static {
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        for (ThreadGroup tgn = tg;
             tgn != null;
             tg = tgn, tgn = tg.getParent());
        Thread finalizer = new FinalizerThread(tg);
     	//普通线程优先级是五，这个是八
        finalizer.setPriority(Thread.MAX_PRIORITY - 2);
     	//这是一个守护线程，即当其他的非守护线程都结束了，守护线程就要结束
        finalizer.setDaemon(true);
        finalizer.start();
    }
~~~

