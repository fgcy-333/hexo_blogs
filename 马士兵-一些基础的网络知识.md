---
title: 基础网络知识
date: 2022-09-06 18:53:48
tags:
- 马士兵
- 网络基础
categories: 
- 视频学习笔记
---



## TCP 与IP与Java中的什么东西相关？

1、高并发，负载均衡

2、集群

3、IO模型（文件IO,网络IO）

​	 网络IO本质是内核给程序暴露API，源于C写的socket

4、分布式，微服务，服务网格，大数据，云计算



<!--more-->



## OSI 七层模型 【理论 尚未实现】

涉及软件工程学-->层与层之间可以解耦

七层模型：

---

![image-20220905234122294](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209052341353.png)

---

应用层 ：协议的使用和逻辑的开发。

表示层

会话层

传输控制层：控制数据怎么传输。

网络层：网络中怎么寻址。

数据链路层：数据在链路中怎么传递。

物理层：以什么特征将高低电频发送出去。





## TCP/IP协议



---

![image-20220906000852938](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209060008048.png)

---



> OSI七层模型只是参考，真正使用的还是TCP/IP协议



## 什么是长连接？

- 所谓的`Http/1.1`(长链接)，就是一个TCP连接中可以有多个请求。

  那么相对的短链接就是一个TCP连接中只能有一个请求。该请求结束后，就会断开TCP连接。

  这个长短的概念是在应用层实现的

- 所谓的`Http/1.1`就是在服务器端与客户端建立好TCP连接后，用一个死循环不断接收IO消息。一次IO（一个请求）就会调用一个线程处理。

  短连接时，服务器端在接收到一次IO（请求）后，就断开连接。其中可以使用线程池实现线程复用。

- 长连接是处于应用层的 `keep alive`

- HTTP/1.0是短链接。





## 三次握手



**三次握手流程图**

---

![image-20220905222701962](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209052227560.png)

---

应用层不能发送消息，需要通过调用内核完成该功能。

客户端想要建立一个连接，它会调用传输层。此时，传输层会创建一个syn的数据包，通过下层传输出去给服务器。

服务器收到这个包后，就会生成一个 `syn+ack` 的包给客户端。此时，客户端可以确认C-->S的通信是正常的。

客户端收到包后，回一个`ack` 的包，此时服务器端确认S--->C的通信是正常的。

> 如果哪一步发送包后，没有收到包，就会有重试机制。直到收到确认包。所以连接是可靠的。



> 三次握手是四层内核完成的，数据传输是端到端的应用层完成的。



## 什么是连接？

通过三次握手建立所谓的连接

---

![image-20220905222055922](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209052220174.png)

---





---

![image-20220906231046326](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209062310182.png)

---

三次握手后，在各自的内存中开辟一块资源。

只要确保对方发送队列中的包会到达自己接受队列中，且自己发送队列中的包会到达对方接受队列中。







**使用Linux的小程序，对其他服务器进行连接**



1、这一步只是建立连接。没有输出任何东西。

---

![image-20220905234556135](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209052346523.png)

---

~~~
nc：是一个小程序，与其他机器建立连接。
~~~





第五条  **条目**   表示这个nc的程序有在使用。

---

![image-20220905234632133](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209052350487.png)

---

`192.168.150.11:36008 <-------->  220.181.38.150:80` 这个东西可以理解为一次连接。

nc是一个程序，`4714`是它的进程id，`ESTABLISHED`表示是一种连通的状态。

`192.168.150.11:36008`是本地的IP地址和一个随机端口

`220.181.38.150:80`是百度的ip和端口











**另一种验证方式：**

> exec   8<>    /dev/tcp/www.baidu.com/80

与百度建立TCP连接

`<`:输入流

`>` ：输出流

`8`: 指向socket的文件描述符（file descriptor）,通过这个8可以操作接收队列和发送队列





> echo	-e	"GET	/	HTTP/1.1\n" >& 8

`-e` ：将`\n`转为换行符

`GET	/	HTTP/1.1\n`：请求行 【请求方式 	资源URI	http版本号】

`>` ：重定向

`1`: 标准输出





> cat	0<&	8

`0`: 标准输入



---

![image-20220908235621004](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209082356485.png)

---









解析文件描述符

---

![image-20220910001406855](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100014837.png)

---





> exec

---

![image-20220910001707226](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100017067.png)

---

~~~
我们一般写的Linux指令，都是交由外壳接收，然后调用内核执行的。
这个外壳，会长时间处于等待系统输入的状态。
使用exec指令，就是用另一个程序(指令)，替换掉外壳(的功能)。
~~~





---

![image-20220910002712920](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100027476.png)

---

~~~
ls 命令会替换掉外壳程序。
所以会显示文件，然后退出程序
~~~





不给出替换命令，啥事也没有

---

![image-20220910003004603](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100030142.png)

---







了解一个Linux的知识点：**重定向**

----

![image-20220910003117523](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100031311.png)

---

~~~
本来使用 ls命令 会在控制台输出文件信息
但是用 ls > aaa.txt
就会重定向到aaa.txt文件中
~~~







任何一个程序都有输入输出流：

---

![image-20220910003542832](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100035383.png)

---



该目录下有很多数字命名的文件，代表进程：【Linux中万物皆文件】

---

![image-20220910003636137](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100036856.png)

---

![image-20220910003803367](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209100038959.png)

----

![image-20220910003832228](C:\Users\fgcy\AppData\Roaming\Typora\typora-user-images\image-20220910003832228.png)

----

~~~
fd是文件描述符的意思


0 代表输入流
1 代表输出流
2 代表报错流
~~~





---

![image-20220910004124571](C:\Users\fgcy\AppData\Roaming\Typora\typora-user-images\image-20220910004124571.png)

---

~~~
ls命令会将文件信息输出到控制台中
ls 也有 输入流 输出流 报错流
将输出流重定向到一个文件
~~~









---

![image-20220910004436180](C:\Users\fgcy\AppData\Roaming\Typora\typora-user-images\image-20220910004436180.png)

---

~~~
echo $$   输出当前解释程序
所以 exec <>8 /dev/tcp/www.baidu.com/80
该命令为 创建一个tcp连接，用数字8代表其输入输出流


echo -e "GET / HTTP/1.1\n" 1>& 8
echo是一个程序也有输入输出报错流，将其的输出流重定向到一个文件描述符，需要多加一个 &
若是给到一个文件则不用&

cat 0<& 8
cat是一个程序，将文件描述符中的输入流读取到 cat程序的输入流中，即输出到控制台中
~~~







## **这里介绍一些程序员接触到的概念:**



---

![image-20220905234632133](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209052350487.png)

---

一行记录代表一个`socket`，一个socket由一个进程为其服务。

当 一个进程为多个socket服务时，这种情况叫做 多路复用器 EPOLL 



`socket` (套接字)，对资源接收队列和发送队列的封装。有四个部分组成：源ip，端口 <----->目标ip，端口  【绝对唯一的连接】

`端口范围`：0~65535





如下图：（理论上客户端可以与服务器建立多少个连接）

---

![image-20220908000751529](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209080007091.png)

---

~~~
65535
~~~









如下图：（理论上客户端可以与服务器建立多少个连接）

---

![image-20220908001126493](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209080011762.png)

---

~~~
65535 * 65535
~~~









经行单机压测时，怎么利用一条客户端对一台服务器产生12万级别的连接。

---

![image-20220908001451745](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209080014174.png)

----

~~~
客户端开两个网卡，理论上每个ip + 端口有65536种组合。两个网卡就是12万。
~~~







---

![image-20220910103459217](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101035904.png)

---









## 四次分手

`分手` ：就是断开连接【同时断开，不可以当方面进行】



四次分手流程图：

---

![image-20220908222721565](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209082227145.png)

---

`fin + ack ` : 这个时候还没有断开连接，它只代表收到的fin这个包，保证可靠性。此时会将没有响应的数据响应回去，将没有释放的资源释放掉，做收尾工作。















问题：

假设内核建立连接后，没有进行数据传输（包括数据包），那么当互联网断开的时候，它们可以感知到嘛？

---

![image-20220908224049985](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209082241839.png)

----

~~~
答案是不能的。
所以内核会有一个心跳机制，以确保是有在连接的。检查连接的健康。
应用上的心跳机制，是确保应用程序的健康.
~~~















在Linux下输入 命令`curl www.baidu.com:80`

---

![image-20220908225300656](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209082253916.png)

---

这条命令包括:	建立连接,接收数据,关闭连接,退出程序.











## Linux抓包 验证三次握手，四次分手

> tcpdump -nn -i eth0 port 80

抓取所有 eth0 网卡的80端口的包，ip与端口号用数值的形式显示。



建立连接后，还需要使用某种协议才可以进行通信。这里使用的是HTTP协议.

---

![image-20220906001159563](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209060012440.png)

---

请求行,请求头,请求空行,请求体



请求行格式:

~~~
请求方式 请求的URI HTTP协议 
~~~





**抓到的包：**

---

![image-20220908230112485](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209082301677.png)

![image-20220908231653330](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209082316691.png)

---

上图包含了完整的三次握手,数据传输,四次分手的过程 如下：

~~~
---------------------------三次握手------------------------------
192.168.150.11.58254  向  182.61.200.7.80 发送一个[S]的数据包，其实是syn数据包 长度为零

182.61.200.7.80 向  192.168.150.11.58254  发送一个[S.]的数据包，其实是syn + ack 数据包 长度为零

192.168.150.11.58254  向  182.61.200.7.80 发送一个[.]的数据包，其实是ack数据包 长度为零


-----------------------------数据传输-----------------------------------
192.168.150.11.58254  向  182.61.200.7.80 发送一个[P.]的数据包，其实是http协议规定的请求格式数据 长度168
182.61.200.7.80 向  192.168.150.11.58254 发送一个[.]的数据包，其实是ack数据包 长度为零【为保证可靠性，收到就会ack】
182.61.200.7.80 向  192.168.150.11.58254 发送一个[P.]的数据包，其实是http协议规定的响应格式数据 长度1400 【一个包最大可穿1400字节】
192.168.150.11.58254  向  182.61.200.7.80 发送一个[.]的数据包，其实是ack数据包 长度为零【为保证可靠性，收到就会ack】
182.61.200.7.80 向  192.168.150.11.58254 发送一个[P.]的数据包，其实是http协议规定的响应格式数据【接上一个会的包】 长度1381【一个包最大可穿1400字节】
192.168.150.11.58254  向  182.61.200.7.80 发送一个[.]的数据包，其实是ack数据包 长度为零【为保证可靠性，收到就会ack】

-----------------------------四次分手-----------------------------------
192.168.150.11.58254  向  182.61.200.7.80 发送一个[F.]的数据包，其实是fin 数据包 长度为零
182.61.200.7.80 向  192.168.150.11.58254 发送一个[.]的数据包,其实是fin + ack 数据包 长度为零
182.61.200.7.80 向  192.168.150.11.58254 发送一个[FP.]的数据包,其实是fin 数据包 长度为零
192.168.150.11.58254  向  182.61.200.7.80 发送一个[.]的数据包，其实是ack数据包 长度为零
~~~

> 注意：这里的[P]代表立刻处理该程序包的意思
>
> 三次握手 数据传输 四次分手 是一个不可分割的过程







高并发场景下需要使用到负载均衡。

LVS基于传输控制层的负载均衡器





---

![image-20220910111828547](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101118306.png)

---

~~~
负载均衡要基于协议约束，不可以破环http协议的三次握手 数据传输 四次分手的过程。
如上图：就不会开辟资源，那么也就没有所谓的连接了。
~~~



## DDos攻击

使用相当数量的机器向服务器发送syn数据包，但收到syn+ack后，就是不会ack的数据包。此时，服务器就会计时等待客户端发送ack的包，如果超过这个时间还没有回，就不会开辟资源。计时等待是需要消耗资源的，当数量过多时就会让服务器内存溢出。





## 网络层



---

![image-20220910165941482](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101659652.png)

---



Linux配置网卡的ip信息：

> vim  /etc/sysconfig/network-srcipt/ifcfg-eth0



---

![image-20220910163938470](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101639658.png)

---



配置信息如下：

---

![image-20220910164103118](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101641373.png)

----

~~~~
IP地址 192.168.150.12 是在网络号为192.168.150.0的网段中的第12号机器
掩码网关
dns服务器地址
~~~~

ipv4是点分字节，一个字节8位，二的八次方就是256 即0~255

一个ip地址 和一个掩码做 按位与 得到的就是一个网络号





---

![image-20220910165630276](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101656265.png)

---

~~~
如果主机a想要与主机d通信那么主机a需要将数据包发给机器F就可以了，机器F称为主机a【局域网 1中的所有主机】的下一条
~~~





在Linux中输入：`route -n`

路由表：

---

![image-20220910170424409](C:\Users\fgcy\AppData\Roaming\Typora\typora-user-images\image-20220910170424409.png)

----





这张路由表是怎么使用的：

----

![image-20220910170845161](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101708721.png)

---

~~~
拿着百度的ip：61.135.169.128 跟路由表中每一条记录做比较
首先是与Genmask做按位与 ，看是否满足Destination的记录，如果符合就走GateWay的记录，若GateWay的记录为0.0.0.0则表示没有网关，是局域网内。从网卡出去，走交换机，到另一台主机，不需要经过路由器。

第三条记录可以匹配，从网关192.168.150.2中出去。
~~~

注意：

网络层封的数据包是源ip地址和目标ip地址，下一跳的ip地址由数据链路层封。

IP地址一定是端到端的



## 数据链路层



链路层表： 使用arp协议

---

![image-20220910172535958](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101725449.png)

---







---

![image-20220910174254509](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101743482.png)

---

~~~
网络层会封一个端到端的IP地址（一直保持不变），找到下一条
链路层会根据下一跳的ip地址获取下一跳的MAC地址，链路层会将MAC地址封到数据包中
~~~







抓包验证：链路层获取下一跳的MAC地址，才可以进行后续的三次握手，数据传输，四次分手

---

![image-20220910175120911](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101751514.png)

---





删除arp表中，记录某个下一跳的MAC地址的记录。

---

![image-20220910175232207](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101752396.png)

----



抓包结果：

---

![image-20220910175304525](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101753662.png)

---







**深入了解路由表：**

---

![image-20220910180033741](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101800627.png)

---

~~~
这里可以看到有两个网卡 eth0【真实的物理网卡】 和lo【虚拟网卡】	
~~~





---

![image-20220910180340212](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101803245.png)

---



问题：

一台主机`192.168.150.13` 可以ping通 在同一个局域网中的主机：`192.168.150.12`

那么主机 `192.168.150.12` 可以ping通 `192.168.88.88`主机嘛？



答案是不能的。

---

![image-20220910181152993](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101811085.png)

---

~~~
因为ping192.168.88.88这台主机时，会拿路由表的每一条记录的Genmask信息，与主机ip地址做按位与。
比对完所有记录后并没有发现按位与后的结果能与Destination相匹配的。所以会丢弃掉
~~~



解决：路由表添加一条记录

---

![image-20220910181901246](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101819311.png)

---



查看路由表：

----

![image-20220910181937275](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101819309.png)

---



尝试ping

---

![image-20220910182049438](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101820267.png)

---





## vpn

---

![image-20220910183419364](https://cdn.jsdelivr.net/gh/fgcy-333/gitnote-images/2022/8/27202209101834783.png)

---





















































































